#' Create an interactive Shiny app for visualization & exploration of MAGeCK RRA CRISPR analyses 
#'
#' This shiny app is composed of three tabs - an interactive heatmap, MA and volcano plots, and a table of full
#' differential expression results. The interactive heatmap will generate a sub-heatmap for selected rows/columns.
#'
#' Gene labels can be added to the MAplot and volcano plot by clicking a point. The labels can also be dragged around,
#' though adding labels will reset the positions, so it's recommended to add all labels prior to re-positioning them.
#'
#' @details Features with no variation will be removed prior to \code{\link[PCAtools]{pca}} being run for the PCA visualization.
#'
#' @rawNamespace import(shiny, except = c(dataTableOutput, renderDataTable))
#' @importFrom ComplexHeatmap Heatmap pheatmap
#' @import DT
#' @importFrom plotly ggplotly plotlyOutput renderPlotly toWebGL plot_ly layout add_annotations config toRGB event_data
#' @import ggplot2
#' @importFrom shinyWidgets prettyCheckbox dropdownButton tooltipOptions
#' @importFrom htmltools tags
#' @importFrom shinycustomloader withLoader
#' @importFrom shinyjqui jqui_resizable
#' @importFrom shinyjs show useShinyjs hidden disable
#' @importFrom colourpicker colourInput
#' @importFrom MAGeCKFlute BarView MapRatesView VolcanoView ScatterView
#' @importFrom PCAtools pca
#' @importFrom dittoSeq dittoColors
#' @importFrom grid grid.newpage grid.text
#' @importFrom matrixStats rowVars
#'
#' @param gene.data A named list containing \code{gene_summary.txt} tables as data.frames. Multiple data.frames may be provided, one per element of the list.
#'   Users will be able to swap between them within the app. List element names should match names of \code{grna.data} list elements.
#' @param sgrna.data A named list containing \code{sgrna_summary.txt} tables as data.frames. Multiple data.frames may be provided, one per element of the list.
#'   Users will be able to swap between them within the app. List element names should match names of \code{gene.data} list elements.
#' @param count.summary Matrix or dataframe containing count summary (\code{countsummary.txt}) as generated by \code{mageck count}.
#' @param norm.counts Matrix or dataframe containing normalized counts (\code{count_normalized.txt}) as generated by \code{mageck count}.
#' @param h.id String indicating unique ID for interactive plots.
#'   Required if multiple apps are run within the same Rmd file.
#' @param use.depmap.essential Boolean indicating whether to download and use DepMap CRISPR and RNAi gene dependency summaries for selective and common essential labeling.
#' @param essential.genes Optional character vector of gene identifiers of common essential genes (i.e. pan-lethal) that can be used for labeling/filtering plots. 
#'   If provided, overrides the depmap essential genes.
#' @param depmap.data Optional named list containing depmap data. 
#' @param genesets Optional named list containing genesets that can be interactively highlighted on the plots.
#'   The elements of the list should each be a geneset with gene identifiers matching those used in the results.
#' @param height Number indicating height of app in pixels.
#'
#' @return A Shiny app containing interactive visualizations of MAGeCK RRA analysis results.
#'
#'
#' @seealso
#' \code{\link[DESeq2]{results}}, \code{\link[DESeq2]{lfcShrink}}, \code{\link[DESeq2]{resultsNames}}.
#'
#' @author Jared Andrews
#' @export
shinyMAGeCK <- function(gene.data, sgrna.data, count.summary, norm.counts, h.id = "mag1", use.depmap.essential = TRUE,
                        essential.genes = NULL, depmap.data = NULL, genesets = NULL, height = 800) {
  
  # Retrieve depmap data.
  if (use.depmap.essential) {
    depmap.gene <- tryCatch(
      {
        depmap.gene <- read.csv("https://depmap.org/portal/api/download/gene_dep_summary")
      },
      error = function(cond) {
        message("DepMap URL does not exist: https://depmap.org/portal/api/download/gene_dep_summary")
        message(cond)
        message("Continuing without DepMap dependency summaries.")
        return(NULL)
      }
    )
  }
  
  ui <- navbarPage(
    "shinyMAGeCK",
    useShinyjs(),
    tags$head(
      # Note the wrapping of the string in HTML()
      tags$style(HTML("
          .panel-body {
            padding: 5px;
          }
          .form-group {
            margin-bottom: 3px;
            padding-bottom: 2px !important;
            padding-top: 2px !important;
            font-size: 10px;
            line-height: 1.1;
          }
          .well {
            padding: 5px;
            margin-bottom: 10px;
          }
          .form-control, .selectize-input {
            padding-bottom: 2px !important;
            padding-top: 2px !important;
            font-size: 10px;
            height: 24px;
            min-height: 24px;
            line-height: 1.1;
          }
          .control-label {
            font-size: 10px;
            margin-bottom: 2px;
          }
          .panel-heading {
            padding: 5px 10px;
          }
          .selectize-control {
            margin-bottom: 0px;
          }
          body {
            line-height: 1.1;
          }
        "))
    ),
    tabPanel("QC",
             sidebarLayout(
               sidebarPanel(
                 width = 2,
                 h4("Plot Controls"),
                 bsCollapse(open = "pca.settings",
                            bsCollapsePanel(
                              title = span(icon("plus"), "PCA Settings"), value = "pca.settings", style = "info",
                              uiOutput("pca.comps"),
                              conditionalPanel(
                                condition = "input['keep.top.n'] == false",
                                numericInput("var.remove", "Remove this proportion of features ranked by variance:",
                                             min = 0, max = 1, step = 0.01, value = 0)
                              ),
                              conditionalPanel(
                                condition = "input['keep.top.n'] == true",
                                numericInput("var.n.keep", "Number of features to retain by variance:",
                                             min = 2, max = Inf, step = 1, value = 500)
                              ),
                              fluidRow(
                                column(6,
                                       prettyCheckbox("center", strong("Center data"), TRUE, bigger = FALSE,
                                                      animation = "smooth", status = "success",
                                                      icon = icon("check"), width = "100%"),
                                       prettyCheckbox("keep.top.n", strong("Limit by top N features"), FALSE, bigger = FALSE,
                                                      animation = "smooth", status = "success",
                                                      icon = icon("check"), width = "100%")
                                ),
                                column(6,
                                       prettyCheckbox("scale", strong("Scale data"), TRUE, bigger = FALSE,
                                                      animation = "smooth", status = "success",
                                                      icon = icon("check"), width = "100%")
                                )
                              ),
                              prettyCheckbox("meta.filt", strong("Filter via metadata table"), TRUE, bigger = FALSE,
                                             animation = "smooth", status = "success",
                                             icon = icon("check"), width = "100%"),
                              fluidRow(
                                column(6, selectInput("bip.color", "Color by:", 
                                                      choices = c("", colnames(count.summary)), selected = "Label")),
                                column(6, selectInput("bip.shape", "Shape by:", 
                                                      choices = c("", colnames(count.summary))))
                              ),
                              fluidRow(
                                column(6,
                                       prettyCheckbox("bip.twod", strong("Limit to 2D"), TRUE, bigger = FALSE,
                                                      animation = "smooth", status = "success",
                                                      icon = icon("check"), width = "100%")
                                ),
                                column(6,
                                       prettyCheckbox("bip.loadings", strong("Plot Loadings"), FALSE, bigger = FALSE,
                                                      animation = "smooth", status = "success",
                                                      icon = icon("check"), width = "100%")
                                )
                              ),
                              numericInput("bip.n.loadings", "Loadings:",
                                           min = 0, max = 100, step = 1, value = 5),
                              div(actionButton("pca.update", "Update PCA"), align = "center")
                            )
                 )
               ),
               mainPanel(
                 width = 10,
                 fluidRow(
                   column(width = 4,
                          jqui_resizable(plotlyOutput("qc.gini")),
                          jqui_resizable(plotOutput("qc.histplot"))
                   ),
                   column(width = 4,
                          jqui_resizable(plotlyOutput("qc.missed")),
                          jqui_resizable(plotOutput("qc.corr"))
                   ),
                   column(width = 4,
                          jqui_resizable(plotOutput("qc.map")),
                          jqui_resizable(plotlyOutput("qc.pca"))
                   )
                 )
               )
             )
    ),
    tabPanel("QC Table",
             br(),
             DTOutput("count.summary")
    ),
    tabPanel("Gene (Overview)",
             sidebarLayout(
               sidebarPanel(
                 width = 2,
                 h4("Plot Controls"),
                 fluidRow(
                   column(6,
                      selectInput("gene.sel1", "Dataset 1:", choices = names(gene.data)),
                      numericInput("gene.fdr.th", "FDR threshold:",
                                   min = 0, max = 1, step = 0.01, value = 0.05)
                   ),
                   column(6,
                      selectInput("gene.sel2", "Dataset 2:", choices = names(gene.data),
                                  selected = ifelse(length(names(gene.data) > 1), names(gene.data)[2], names(gene.data)[1])),
                      numericInput("gene.lfc.th", "log2FC threshold:",
                                   min = 0, max = Inf, step = 0.05, value = 0.5)
                   )
                 ),
                 fluidRow(
                   column(12,
                     prettyCheckbox("rem.ess", label = "Remove essential genes", value = FALSE,
                       animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                     prettyCheckbox("dep.crispr.ess", label = "Remove DepMap CRISPR essential genes", value = FALSE,
                                    animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                     prettyCheckbox("dep.rnai.ess", label = "Remove DepMap RNAi essential genes", value = FALSE,
                                    animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                     prettyCheckbox("dep.crispr.sel", label = "Remove DepMap CRISPR selective genes", value = FALSE,
                                    animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                     prettyCheckbox("dep.rnai.sel", label = "Remove DepMap RNAi selective genes", value = FALSE,
                                    animation = "smooth", status = "success", bigger = TRUE, icon = icon("check"))
                   )
                 ),
                 bsCollapse(open = "vol.settings",
                    bsCollapsePanel(
                      title = span(icon("plus"), "Volcano Plot Settings"), value = "vol.settings", style = "info",
                      fluidRow(
                        column(width = 6,
                               colourInput("vol.down.color", "Down colour", value = "#0026ff"),
                               colourInput("vol.up.color", "Up colour", value = "red"),
                               colourInput("vol.insig.color", "Insig colour", value = "#A6A6A6"),
                               numericInput("vol.sig.opa", label = "Sig opacity:", value = 1, step = 0.05, min = 0),
                               numericInput("vol.sig.size", label = "Sig pt size:", value = 6, step = 0.1, min = 0)
                        ),
                        column(width = 6,
                               numericInput("vol.x", label = "x-axis limits:", value = 5, step = 0.1, min = 0.1),
                               numericInput("vol.y", label = "y-axis limits:", value = 5, step = 0.5, min = 1),
                               numericInput("vol.lab.size", label = "Label size:", value = 10, step = 0.5, min = 1),
                               numericInput("vol.insig.opa", label = "Insig opacity:", value = 0.5, step = 0.05, min = 0),
                               numericInput("vol.insig.size", label = "Insig pt size:", value = 5, step = 0.1, min = 0)
                        )
                      ),
                      splitLayout(
                        prettyCheckbox("vol.fcline", label = "Show FC threshold", value = TRUE,
                                       animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                        prettyCheckbox("vol.hl.counts", label = "Show highlight counts", value = FALSE,
                                       animation = "smooth", status = "success", bigger = TRUE, icon = icon("check"))
                      ),
                      splitLayout(
                        prettyCheckbox("vol.sigline", label = "Show Sig. threshold", value = TRUE,
                                       animation = "smooth", status = "success", bigger = TRUE, icon = icon("check"))
                      ),
                      splitLayout(
                        prettyCheckbox("vol.counts", label = "Show counts", TRUE, bigger = TRUE,
                                       animation = "smooth", status = "success",
                                       icon = icon("check"), width = "100%"),
                        prettyCheckbox("vol.webgl", label = "Use webGL", FALSE, bigger = TRUE,
                                       animation = "smooth", status = "success",
                                       icon = icon("check"), width = "100%")
                      ),
                      splitLayout(
                        numericInput("vol.counts.size", label = "Counts size:", value = 8, step = 0.1, min = 0),
                        numericInput("vol.webgl.ratio", label = "webGL pixel ratio:", value = 7, step = 0.1, min = 1)
                      ),
                      div(actionButton("vol.update", "Update Volcano Plots"), align = "center")
                    ),
                    bsCollapsePanel(
                      title = span(icon("plus"), "Rank Plot Settings"), value = "rank.settings", style = "info",
                      fluidRow(
                        column(width = 6,
                               numericInput("rank.y.max", label = "y-axis max:", value = 2, step = 0.5),
                               colourInput("rank.down.color", "Down colour", value = "#0026ff"),
                               colourInput("rank.up.color", "Up colour", value = "red"),
                               colourInput("rank.insig.color", "Insig colour", value = "#A6A6A6"),
                               numericInput("rank.sig.opa", label = "Sig opacity:", value = 1, step = 0.05, min = 0),
                               prettyCheckbox("rank.fcline", label = "Show FC threshold", value = TRUE,
                                              animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                        ),
                        column(width = 6,
                               numericInput("rank.y.min", label = "y-axis min:", value = -10, step = 0.5, min = 1),
                               numericInput("rank.lab.size", label = "Label size:", value = 10, step = 0.5, min = 1),
                               numericInput("rank.insig.opa", label = "Insig opacity:", value = 0.5, step = 0.05, min = 0),
                               numericInput("rank.insig.size", label = "Insig pt size:", value = 5, step = 0.1, min = 0),
                               numericInput("rank.sig.size", label = "Sig pt size:", value = 6, step = 0.1, min = 0),
                               prettyCheckbox("rank.hl.counts", label = "Show highlight counts", value = FALSE,
                                              animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                        )
                      ),
                      splitLayout(
                        prettyCheckbox("rank.counts", label = "Show counts", TRUE, bigger = TRUE,
                                       animation = "smooth", status = "success",
                                       icon = icon("check"), width = "100%"),
                        prettyCheckbox("rank.webgl", label = "Use webGL", FALSE, bigger = TRUE,
                                       animation = "smooth", status = "success",
                                       icon = icon("check"), width = "100%")
                      ),
                      splitLayout(
                        numericInput("rank.counts.size", label = "Counts size:", value = 8, step = 0.1, min = 0),
                        numericInput("rank.webgl.ratio", label = "webGL pixel ratio:", value = 7, step = 0.1, min = 1)
                      ),
                      div(actionButton("rank.update", "Update Rank Plots"), align = "center")
                    ),
                    bsCollapsePanel(
                      title = span(icon("plus"), "Lawn Plot Settings"), value = "lawn.settings", style = "info",
                      fluidRow(
                        column(width = 6,
                               colourInput("lawn.down.color", "Down colour", value = "#0026ff"),
                               colourInput("lawn.up.color", "Up colour", value = "red"),
                               colourInput("lawn.insig.color", "Insig colour", value = "#A6A6A6"),
                               numericInput("lawn.sig.opa", label = "Sig opacity:", value = 1, step = 0.05, min = 0),
                               numericInput("lawn.sig.size", label = "Sig pt size:", value = 6, step = 0.1, min = 0)
                        ),
                        column(width = 6,
                               numericInput("lawn.y", label = "y-axis limits:", value = 5, step = 0.5, min = 1),
                               numericInput("lawn.lab.size", label = "Label size:", value = 10, step = 0.5, min = 1),
                               numericInput("lawn.insig.opa", label = "Insig opacity:", value = 0.5, step = 0.05, min = 0),
                               numericInput("lawn.insig.size", label = "Insig pt size:", value = 5, step = 0.1, min = 0)
                        )
                      ),
                      splitLayout(
                        prettyCheckbox("lawn.hl.counts", label = "Show highlight counts", value = FALSE,
                                       animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                        prettyCheckbox("lawn.sigline", label = "Show Sig. threshold", value = TRUE,
                                       animation = "smooth", status = "success", bigger = TRUE, icon = icon("check"))
                      ),
                      splitLayout(
                        prettyCheckbox("lawn.counts", label = "Show counts", TRUE, bigger = TRUE,
                                       animation = "smooth", status = "success",
                                       icon = icon("check"), width = "100%"),
                        prettyCheckbox("lawn.webgl", label = "Use webGL", FALSE, bigger = TRUE,
                                       animation = "smooth", status = "success",
                                       icon = icon("check"), width = "100%")
                      ),
                      splitLayout(
                        numericInput("lawn.counts.size", label = "Counts size:", value = 8, step = 0.1, min = 0),
                        numericInput("lawn.webgl.ratio", label = "webGL pixel ratio:", value = 7, step = 0.1, min = 1)
                      ),
                      div(actionButton("lawn.update", "Update Lawn Plots"), align = "center")
                    ),
                    bsCollapsePanel(title = span(icon("plus"), "Highlight Gene(sets)"), style = "info",
                      textAreaInput("hl.genes", "Highlight Genes:", value = "", rows = 4,
                                    placeholder = "Enter space, comma, or newline delimited genes"),
                      pickerInput("hl.genesets", "Highlight Genesets:", choices = c("", names(genesets)),
                                  multiple = TRUE, options = list(`live-search` = TRUE,
                                                                  `actions-box` = TRUE)),
                      fluidRow(
                        column(6,
                               numericInput("hl.genes.opa", label = "Genes opacity:", value = 1, step = 0.05, min = 0),
                               numericInput("hl.genes.size", label = "Genes pt size:", value = 7, step = 0.1, min = 0),
                               numericInput("hl.genes.lw", label = "Genes border width:", value = 1, step = 0.05, min = 0),
                               colourInput("hl.genes.col", "Genes color:", value = "#E69F00"),
                               colourInput("hl.genes.lcol", "Genes border:", value = "#000000")),
                        column(6,
                               numericInput("hl.genesets.opa", label = "Sets opacity:", value = 1, step = 0.05, min = 0),
                               numericInput("hl.genesets.size", label = "Sets pt size:", value = 7, step = 0.1, min = 0),
                               numericInput("hl.genesets.lw", label = "Sets border width:", value = 1, step = 0.05, min = 0),
                               colourInput("hl.genesets.col", "Sets color:", value = "#009E73"),
                               colourInput("hl.genesets.lcol", "Sets border:", value = "#000000"))
                      )
                    )
                 )
               ),
               mainPanel(
                 width = 10,
                 fluidRow(
                   column(width = 4,
                          jqui_resizable(plotlyOutput("gene1.vol"))
                   ),
                   column(width = 4,
                          jqui_resizable(plotlyOutput("gene1.rank"))
                   ),
                   column(width = 4,
                          jqui_resizable(plotlyOutput("gene1.lawn"))
                   )
                 ),
                 hr(),
                 fluidRow(
                   column(width = 4,
                          jqui_resizable(plotlyOutput("gene2.vol"))
                   ),
                   column(width = 4,
                          jqui_resizable(plotlyOutput("gene2.rank"))
                   ),
                   column(width = 4,
                          jqui_resizable(plotlyOutput("gene2.lawn"))
                   )
                 )
               )
             )
    ),
    tabPanel("Gene Summary Tables",
             br(),
             div(DT::dataTableOutput("gene1.summary"), style = "font-size:80%;"),
             br(),
             div(DT::dataTableOutput("gene2.summary"), style = "font-size:80%;")
    ),
    tabPanel("sgRNA",
    ),
    tabPanel("Enrichment",
    ),
    tabPanel("DepMap",
    )
  )
  
  server <- function(input, output, session) {
    
    # Load the gene summaries for easy plotting.
    set1.genes <- reactive({
      df <- gene.data[[input$gene.sel1]]
      .gene_ingress(df, sig.thresh = input$gene.fdr.th, lfc.thresh = input$gene.lfc.th, essential.genes = essential.genes, depmap.genes = depmap.gene)
    })
    
    set2.genes <- reactive({
      df <- gene.data[[input$gene.sel2]]
      .gene_ingress(df, sig.thresh = input$gene.fdr.th, lfc.thresh = input$gene.lfc.th, essential.genes = essential.genes, depmap.genes = depmap.gene)
    })
    
    # Keep track of which genes have been clicked
    clicked <- reactiveValues(volc1 = NULL, rank1 = NULL, lawn1 = NULL, volc2 = NULL, rank2 = NULL, lawn2 = NULL)
    
    # On click, the key field of the event data contains the gene symbol
    # Add that gene to the set of all "selected" genes.
    # TODO: lapply this, probably.
    observeEvent(event_data("plotly_click", source = paste0(h.id,"_volc1")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_volc1"))
      gene_old_new <- rbind(clicked$volc1, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]
      
      if (nrow(keep) == 0) {
        clicked$volc1 <- NULL
      } else {
        clicked$volc1 <- keep
      }
    })
    
    observeEvent(event_data("plotly_click", source = paste0(h.id,"_rank1")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_rank1"))
      gene_old_new <- rbind(clicked$rank1, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]
      
      if (nrow(keep) == 0) {
        clicked$rank1 <- NULL
      } else {
        clicked$rank1 <- keep
      }
    })
    
    observeEvent(event_data("plotly_click", source = paste0(h.id,"_lawn1")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_lawn1"))
      gene_old_new <- rbind(clicked$lawn1, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]
      
      if (nrow(keep) == 0) {
        clicked$lawn1 <- NULL
      } else {
        clicked$lawn1 <- keep
      }
    })
    
    observeEvent(event_data("plotly_click", source = paste0(h.id,"_volc2")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_volc2"))
      gene_old_new <- rbind(clicked$volc2, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]
      
      if (nrow(keep) == 0) {
        clicked$volc2 <- NULL
      } else {
        clicked$volc2 <- keep
      }
    })
    
    observeEvent(event_data("plotly_click", source = paste0(h.id,"_rank2")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_rank2"))
      gene_old_new <- rbind(clicked$rank2, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]
      
      if (nrow(keep) == 0) {
        clicked$rank2 <- NULL
      } else {
        clicked$rank2 <- keep
      }
    })
    
    observeEvent(event_data("plotly_click", source = paste0(h.id,"_lawn2")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_lawn2"))
      gene_old_new <- rbind(clicked$lawn2, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]
      
      if (nrow(keep) == 0) {
        clicked$lawn2 <- NULL
      } else {
        clicked$lawn2 <- keep
      }
    })
    
    # clear the set of genes when a double-click occurs
    # TODO: lapply this, probably.
    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_volc1")), {
      clicked$volc1 <- NULL
    })
    
    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_rank1")), {
      clicked$rank1 <- NULL
    })
    
    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_lawn1")), {
      clicked$lawn1 <- NULL
    })
    
    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_volc2")), {
      clicked$volc2 <- NULL
    })
    
    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_rank2")), {
      clicked$rank2 <- NULL
    })
    
    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_lawn2")), {
      clicked$lawn2 <- NULL
    })
    
    # PCA.
    pc <- reactive({
      slmed <- norm.counts
      slmat <- as.matrix(slmed[,c(-1,-2)])
      mat <- log2(slmat+1)
      rownames(mat) <- slmed$sgRNA
      
      req(input$var.remove)
      meta <- count.summary
      
      # Filter samples from QC table.
      if (!is.null(input$count.summary_rows_all) & input$meta.filt) {
        meta <- count.summary[input$count.summary_rows_all,]
        mat <- mat[,input$count.summary_rows_all]
      }
      
      rownames(meta) <- gsub("-", ".", meta$Label)
      
      # Remove guides with no variance in counts, as they break the PCA.
      mat <- mat[(rowMaxs(mat) - rowMins(mat) > 0),]
      
      # If input to use top N features instead rather than percent-based feature removal, account for that
      if (input$keep.top.n) {
        mat <- mat[order(rowVars(mat), decreasing = TRUE),]
        mat <- mat[1:input$var.n.keep,]
        var.remove <- 0
      } else {
        var.remove <- input$var.remove
      }
      
      if (ncol(mat) > 1) {
        pca(mat, metadata = meta, removeVar = var.remove, scale = input$scale, center = input$center)
      } else {
        NULL
      }
    })
    
    # Populate UI with all PCs.
    # TODO: Write check for only 2 PCs.
    output$pca.comps <- renderUI({
      req(pc)
      local({
        pcs <- pc()
        
        tagList(
          fluidRow(
            column(4, selectInput("dim1", "Dim1:", choices = pcs$components, selected = "PC1")),
            column(4, selectInput("dim2", "Dim2:", choices = pcs$components, selected = "PC2")),
            column(4, selectInput("dim3", "Dim3:", choices = pcs$components, selected = "PC3"))
          )
        )
      })
    })
    
    output$qc.gini <- renderPlotly({
      gg <- BarView(count.summary, x = "Label", y = "GiniIndex",
                    ylab = "Gini index", main = "sgRNA Read Distribution")
      
      gg + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 12),
                 axis.text.y = element_text(size = 12)) 
      
      ggplotly(gg, tooltip = c("y")) %>% 
        layout(yaxis = list(range = list(0, max(count.summary$GiniIndex) + .05)), 
               xaxis = list(tickangle = 315))
    })
    
    output$qc.missed <- renderPlotly({
      gg <- BarView(count.summary, x = "Label", y = "Zerocounts", fill = "#394E80",
                    ylab = "Zero Count sgRNAs", main = "Fully Depleted sgRNAs")
      
      gg + theme_classic() + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 12),
                                   axis.text.y = element_text(size = 12)) + ylim(0, max(count.summary$Zerocounts) + 5)
      
      ggplotly(gg, tooltip = c("y")) %>% 
        layout(yaxis = list(range = list(0, max(count.summary$Zerocounts) + 5)), 
               xaxis = list(tickangle = 315))
    })
    
    output$qc.map <- renderPlot({
      MapRatesView(count.summary)
    })
    
    # TODO: rewrite this.
    output$qc.histplot <- renderPlot({
      colors <- dittoColors()
      
      slmed <- norm.counts
      tabsmat <- as.matrix(log2(slmed[,c(-1,-2)] + 1))
      colnames(tabsmat) <- colnames(slmed)[c(-1,-2)]
      samplecol <- colors[((1:ncol(tabsmat)) %% length(colors)) ]
      tgz <- hist(tabsmat, breaks = 40)
      if(ncol(tabsmat) >= 1) {
        histlist <- lapply(1:ncol(tabsmat), function(X) { return (hist(tabsmat[,X], plot=FALSE, breaks=tgz$breaks)) })
        xrange <- range(unlist(lapply(histlist, function(X) {X$mids})))
        yrange <- range(unlist(lapply(histlist, function(X) {X$counts})))
        hst1 <- histlist[[1]]
        plot(hst1$mids,hst1$counts, type='b', pch=20, xlim=c(0,xrange[2]*1.2), 
             ylim=c(0,yrange[2]*1.2), xlab='log2(counts)', ylab='Frequency', 
             main='Distribution of read counts', col = samplecol[1])
      }
      if(ncol(tabsmat) >= 2){ 
        for(i in 2:ncol(tabsmat)){
          hstn <- histlist[[i]]
          lines(hstn$mids, hstn$counts, type='b', pch=20, col=samplecol[i])
        }
      }
      legend('topright', colnames(tabsmat), pch=20, lwd=1, col=samplecol)
    })
    
    # TODO: rewrite this, add color min/max/mid selectors.
    output$qc.corr <- renderPlot({
      slmed <- norm.counts
      slmat <- as.matrix(slmed[,c(-1,-2)])
      slmat.log <- log2(slmat+1)
      
      if (ncol(slmat.log) > 1){
        ComplexHeatmap::pheatmap(cor(slmat.log), 
                                 heatmap_legend_param = list(title = "Pearson\nCorr."), main = "Correlation Matrix")
      } else {
        grid.newpage()
        grid.text("Only one sample, no correlation possible.")
      }
    })
    
    # TODO: rewrite this, add inputs.
    output$qc.pca <- renderPlotly({
      req(pc, input$dim1, input$dim2, input$dim3)
      input$pca.update
      
      pc.res <- isolate(pc())
      
      pl.cols <- NULL
      pl.shapes <- NULL
      pl.col <- "black"
      hov.text <- NULL
      
      # Get marker aesthetics mappings.
      # Drop unused factor levels if possible.
      if (isolate(input$bip.color) != "") {
        pl.cols <- pc.res$metadata[,isolate(input$bip.color), drop = TRUE]
        if (is.factor(pl.cols)) {
          pl.cols <- droplevels(pl.cols)
        }
        pl.col <- dittoColors()[seq_along(unique(pc.res$metadata[,isolate(input$bip.color), drop = TRUE]))]
      }
      
      if (isolate(input$bip.shape) != "") {
        pl.shapes <- pc.res$metadata[,isolate(input$bip.shape), drop = TRUE]
        if (is.factor(pl.shapes)) {
          pl.shapes <- droplevels(pl.shapes)
        }
      }
      
      # Just throw label on hover for now.
      hov.text <- paste0("</br><b>Label:</b> ", pc.res$metadata$Label)
      
      # Check if 2D is wanted.
      if (isolate(input$bip.twod)) {
        fig <- plot_ly(pc.res$rotated, x = as.formula(paste0("~", isolate(input$dim1))),
                       y = as.formula(paste0("~", isolate(input$dim2))),
                       type = "scatter",
                       mode = "markers",
                       marker = list(size = 15),
                       color = pl.cols,
                       colors = pl.col,
                       symbol = pl.shapes,
                       symbols = c("circle", "square", "diamond", "cross",
                                   "diamond-open", "circle-open", "square-open", "x"),
                       text = hov.text,
                       hoverinfo = "text") %>%
          layout(xaxis = list(showgrid = FALSE, showline = TRUE, mirror = TRUE, zeroline = FALSE,
                              title = paste0(isolate(input$dim1),
                                             " (", format(round(pc.res$variance[isolate(input$dim1)], 2), nsmall = 2),"%)")),
                 yaxis = list(showgrid = FALSE, showline = TRUE, mirror = TRUE, zeroline = FALSE,
                              title = paste0(isolate(input$dim2),
                                             " (", format(round(pc.res$variance[isolate(input$dim2)], 2), nsmall = 2),"%)")))
        
        fig <- fig %>% toWebGL()
        
        # Plot loadings.
        if (isolate(input$bip.loadings)) {
          lengthLoadingsArrowsFactor <- 1.5
          
          # Get number of loadings to display.
          xidx <- order(abs(pc.res$loadings[,isolate(input$dim1)]), decreasing = TRUE)
          yidx <- order(abs(pc.res$loadings[,isolate(input$dim2)]), decreasing = TRUE)
          vars <- unique(c(
            rownames(pc.res$loadings)[xidx][seq_len(isolate(input$bip.n.loadings))],
            rownames(pc.res$loadings)[yidx][seq_len(isolate(input$bip.n.loadings))]))
          
          # get scaling parameter to match between variable loadings and rotated loadings
          # This is cribbed almost verbatim from PCAtools code.
          r <- min(
            (max(pc.res$rotated[,isolate(input$dim1)]) - min(pc.res$rotated[,isolate(input$dim1)]) /
               (max(pc.res$loadings[,isolate(input$dim1)]) - min(pc.res$loadings[,isolate(input$dim1)]))),
            (max(pc.res$rotated[,isolate(input$dim2)]) - min(pc.res$rotated[,isolate(input$dim2)]) /
               (max(pc.res$loadings[,isolate(input$dim2)]) - min(pc.res$loadings[,isolate(input$dim2)]))))
          
          fig <- fig %>%
            add_segments(x = 0, xend = pc.res$loadings[vars,isolate(input$dim1)] * r * lengthLoadingsArrowsFactor,
                         y = 0, yend = pc.res$loadings[vars,isolate(input$dim2)] * r * lengthLoadingsArrowsFactor,
                         line = list(color = 'black'), inherit = FALSE, showlegend = FALSE, hoverinfo = "text") %>%
            add_annotations(x = pc.res$loadings[vars,isolate(input$dim1)] * r * lengthLoadingsArrowsFactor,
                            y = pc.res$loadings[vars,isolate(input$dim2)] * r * lengthLoadingsArrowsFactor,
                            ax = 0, ay = 0, text = vars, xanchor = 'center', yanchor= 'bottom')
        }
      } else {
        
        # Generate plot.
        fig <- plot_ly(pc.res$rotated, x = as.formula(paste0("~", isolate(input$dim1))),
                       y = as.formula(paste0("~", isolate(input$dim2))),
                       z = as.formula(paste0("~", isolate(input$dim3))),
                       type = "scatter3d",
                       mode = "markers",
                       color = pl.cols,
                       colors = pl.col,
                       symbol = pl.shapes,
                       symbols = c("circle", "square", "diamond", "cross", "diamond-open",
                                   "circle-open", "square-open", "x"),
                       text = hov.text,
                       hoverinfo = "text") %>%
          layout(scene = list(
            xaxis = list(title = paste0(isolate(input$dim1), " (",
                                        format(round(pc.res$variance[isolate(input$dim1)], 2), nsmall = 2),"%)")),
            yaxis = list(title = paste0(isolate(input$dim2), " (",
                                        format(round(pc.res$variance[isolate(input$dim2)], 2), nsmall = 2),"%)")),
            zaxis = list(title = paste0(isolate(input$dim3), " (",
                                        format(round(pc.res$variance[isolate(input$dim3)], 2), nsmall = 2),"%)")),
            camera = list(eye = list(x=1.5, y = 1.8, z = 0.4))))
      }
      fig <- fig %>%
        config(edits = list(annotationPosition = TRUE,
                            annotationTail = FALSE),
               toImageButtonOptions = list(format = "svg"),
               displaylogo = FALSE,
               plotGlPixelRatio = 7)
      
      fig
    })
    
    output$count.summary <- renderDT({
      DT::datatable(count.summary,
                    rownames = FALSE,
                    filter = "top",
                    extensions = c("Buttons", "Scroller"),
                    options = list(
                      search = list(regex = TRUE),
                      lengthMenu = list(c(10, 25, 50, -1), c("10", "25", "50", "all")),
                      dom = 'Blfrtip',
                      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                      scrollX = TRUE,
                      deferRender = TRUE,
                      scrollY = 600,
                      scroller = TRUE)
      ) %>% DT::formatStyle(0, target = "row", lineHeight = '80%')
    })
    
    output$gene1.summary <- renderDT({
      req(set1.genes)
      # Remove columns that are redundant or confusing.
      target <- which(names(set1.genes()) %in% c("neg|score", "neg|p-value", "neg|rank",  
                                                 "neg|lfc", "pos|score", "pos|p-value", "pos|rank",  
                                                 "pos|lfc", "RandomIndex", "Rank", "goodsgrna")) - 1
      
      DT::datatable(set1.genes(),
                    rownames = FALSE,
                    filter = "top",
                    extensions = c("Buttons"),
                    caption = paste0(input$gene.sel1, " Gene Summary"),
                    options = list(
                      search = list(regex = TRUE),
                      pageLength = 10,
                      dom = 'Blfrtip',
                      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                      columnDefs = list(list(visible = FALSE, targets = target)))
      ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
    })
    
    output$gene2.summary <- renderDT({
      req(set2.genes)
      # Remove columns that are redundant or confusing.
      target <- which(names(set2.genes()) %in% c("neg|score", "neg|p-value", "neg|rank",  
                                                 "neg|lfc", "pos|score", "pos|p-value", "pos|rank",  
                                                 "pos|lfc", "RandomIndex", "Rank", "goodsgrna")) - 1
      
      DT::datatable(set2.genes(),
                    rownames = FALSE,
                    filter = "top",
                    extensions = c("Buttons"),
                    caption = paste0(input$gene.sel2, " Gene Summary"),
                    options = list(
                      search = list(regex = TRUE),
                      dom = 'Blfrtip',
                      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                      pageLength = 10,
                      columnDefs = list(list(visible = FALSE, targets = target)))
      ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
    })
    
    output$gene1.vol <- renderPlotly({
      req(set1.genes)
      input$vol.update
      
      res <- set1.genes()
      
      hov.info <- c("hit_type", "goodsgrna")
      
      # Remove common essential genes if needed.
      if (input$rem.ess & !is.null(res$essential)) {
        res <- res[!res$essential,]
      }
      
      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (input$dep.crispr.ess) {
          res <- res[!res$DepMap_CRISPR_Essential,]
        }
        
        if (input$dep.crispr.sel) {
          res <- res[!res$DepMap_CRISPR_Selective,]
        }
        
        if (input$dep.rnai.ess) {
          res <- res[!res$DepMap_RNAi_Essential,]
        }
        
        if (input$dep.rnai.sel) {
          res <- res[!res$DepMap_RNAi_Selective,]
        }
      }

      .make_volcano(res = res,
                    xlim = isolate(input$vol.x),
                    ylim = isolate(input$vol.y),
                    fc.thresh = isolate(input$gene.lfc.th),
                    fc.lines = isolate(input$vol.fcline),
                    sig.thresh = isolate(input$gene.fdr.th),
                    sig.line = isolate(input$vol.sigline),
                    h.id = h.id,
                    h.id.suffix = "_volc1",
                    sig.term = "FDR",
                    lfc.term = "LFC",
                    feat.term = "id",
                    hover.info = hov.info,
                    fs = clicked$volc1,
                    up.color = isolate(input$vol.up.color),
                    down.color = isolate(input$vol.down.color),
                    insig.color = isolate(input$vol.insig.color),
                    sig.opacity = isolate(input$vol.sig.opa),
                    insig.opacity = isolate(input$vol.insig.opa),
                    sig.size = isolate(input$vol.sig.size),
                    insig.size = isolate(input$vol.insig.size),
                    label.size = isolate(input$vol.lab.size),
                    webgl = isolate(input$vol.webgl),
                    webgl.ratio = isolate(input$vol.webgl.ratio),
                    show.counts = isolate(input$vol.counts),
                    show.hl.counts = isolate(input$vol.hl.counts),
                    counts.size = isolate(input$vol.counts.size),
                    highlight.featsets = isolate(input$hl.genesets),
                    highlight.feat = isolate(input$hl.genes),
                    featsets = genesets,
                    highlight.feats.color = isolate(input$hl.genes.col),
                    highlight.feats.size = isolate(input$hl.genes.size),
                    highlight.feats.opac = isolate(input$hl.genes.opa),
                    highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                    highlight.feats.linewidth = isolate(input$hl.genes.lw),
                    highlight.featsets.color = isolate(input$hl.genesets.col),
                    highlight.featsets.size = isolate(input$hl.genesets.size),
                    highlight.featsets.opac = isolate(input$hl.genesets.opa),
                    highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                    highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
    })
    
    output$gene1.rank <- renderPlotly({
      req(set1.genes)
      input$rank.update
      
      df <- set1.genes()
      
      # Remove common essential genes if needed.
      hov.info <- c("hit_type", "goodsgrna")
      
      # Remove common essential genes if needed.
      if (input$rem.ess & !is.null(df$essential)) {
        df <- df[!df$essential,]
      }
      
      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (input$dep.crispr.ess) {
          df <- df[!df$DepMap_CRISPR_Essential,]
        }
        
        if (input$dep.crispr.sel) {
          df <- df[!df$DepMap_CRISPR_Selective,]
        }
        
        if (input$dep.rnai.ess) {
          df <- df[!df$DepMap_RNAi_Essential,]
        }
        
        if (input$dep.rnai.sel) {
          df <- df[!df$DepMap_RNAi_Selective,]
        }
      }
      
      .make_rank(df = df,
                    ylim = list(isolate(input$rank.y.min), isolate(input$rank.y.max)),
                    y.thresh = isolate(input$gene.lfc.th),
                    y.lines = isolate(input$rank.fcline),
                    sig.thresh = isolate(input$gene.fdr.th),
                    h.id = h.id,
                    h.id.suffix = "_rank1",
                    sig.term = "FDR",
                    y.term = "LFC",
                 x.term = "Rank",
                    feat.term = "id",
                 hover.info = c("hit_type", "goodsgrna"),
                    fs = clicked$rank1,
                    up.color = isolate(input$rank.up.color),
                    down.color = isolate(input$rank.down.color),
                    insig.color = isolate(input$rank.insig.color),
                    sig.opacity = isolate(input$rank.sig.opa),
                    insig.opacity = isolate(input$rank.insig.opa),
                    sig.size = isolate(input$rank.sig.size),
                    insig.size = isolate(input$rank.insig.size),
                    label.size = isolate(input$rank.lab.size),
                    webgl = isolate(input$rank.webgl),
                    webgl.ratio = isolate(input$rank.webgl.ratio),
                    show.counts = isolate(input$rank.counts),
                    show.hl.counts = isolate(input$rank.hl.counts),
                    counts.size = isolate(input$rank.counts.size),
                    highlight.featsets = isolate(input$hl.genesets),
                    highlight.feat = isolate(input$hl.genes),
                    featsets = genesets,
                    highlight.feats.color = isolate(input$hl.genes.col),
                    highlight.feats.size = isolate(input$hl.genes.size),
                    highlight.feats.opac = isolate(input$hl.genes.opa),
                    highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                    highlight.feats.linewidth = isolate(input$hl.genes.lw),
                    highlight.featsets.color = isolate(input$hl.genesets.col),
                    highlight.featsets.size = isolate(input$hl.genesets.size),
                    highlight.featsets.opac = isolate(input$hl.genesets.opa),
                    highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                    highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
    })
    
    output$gene1.lawn <- renderPlotly({
      req(set1.genes)
      df <- set1.genes()
      
      # Remove common essential genes if needed.
      if (input$rem.ess & !is.null(df$essential)) {
        df <- df[!df$essential,]
      }
      
      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (input$dep.crispr.ess) {
          df <- df[!df$DepMap_CRISPR_Essential,]
        }
        
        if (input$dep.crispr.sel) {
          df <- df[!df$DepMap_CRISPR_Selective,]
        }
        
        if (input$dep.rnai.ess) {
          df <- df[!df$DepMap_RNAi_Essential,]
        }
        
        if (input$dep.rnai.sel) {
          df <- df[!df$DepMap_RNAi_Selective,]
        }
      }
      
      .make_lawn(res = df,
                    ylim = isolate(input$lawn.y),
                    fc.thresh = isolate(input$gene.lfc.th),
                    sig.thresh = isolate(input$gene.fdr.th),
                    sig.line = isolate(input$lawn.sigline),
                    h.id = h.id,
                    h.id.suffix = "_lawn1",
                    sig.term = "FDR",
                    lfc.term = "LFC",
                    feat.term = "id",
                 x.term = "RandomIndex",
                    hover.info = c("hit_type", "goodsgrna"),
                    fs = clicked$lawn1,
                    up.color = isolate(input$lawn.up.color),
                    down.color = isolate(input$lawn.down.color),
                    insig.color = isolate(input$lawn.insig.color),
                    sig.opacity = isolate(input$lawn.sig.opa),
                    insig.opacity = isolate(input$lawn.insig.opa),
                    sig.size = isolate(input$lawn.sig.size),
                    insig.size = isolate(input$lawn.insig.size),
                    label.size = isolate(input$lawn.lab.size),
                    webgl = isolate(input$lawn.webgl),
                    webgl.ratio = isolate(input$lawn.webgl.ratio),
                    show.counts = isolate(input$lawn.counts),
                    show.hl.counts = isolate(input$lawn.hl.counts),
                    counts.size = isolate(input$lawn.counts.size),
                    highlight.featsets = isolate(input$hl.genesets),
                    highlight.feat = isolate(input$hl.genes),
                    featsets = genesets,
                    highlight.feats.color = isolate(input$hl.genes.col),
                    highlight.feats.size = isolate(input$hl.genes.size),
                    highlight.feats.opac = isolate(input$hl.genes.opa),
                    highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                    highlight.feats.linewidth = isolate(input$hl.genes.lw),
                    highlight.featsets.color = isolate(input$hl.genesets.col),
                    highlight.featsets.size = isolate(input$hl.genesets.size),
                    highlight.featsets.opac = isolate(input$hl.genesets.opa),
                    highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                    highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
      
    })
    
    output$gene2.vol <- renderPlotly({
      req(set2.genes)
      input$vol.update
      
      res <- set2.genes()
      
      hov.info <- c("hit_type", "goodsgrna")
      
      # Remove common essential genes if needed.
      if (input$rem.ess & !is.null(res$essential)) {
        res <- res[!res$essential,]
      }
      
      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (input$dep.crispr.ess) {
          res <- res[!res$DepMap_CRISPR_Essential,]
        }
        
        if (input$dep.crispr.sel) {
          res <- res[!res$DepMap_CRISPR_Selective,]
        }
        
        if (input$dep.rnai.ess) {
          res <- res[!res$DepMap_RNAi_Essential,]
        }
        
        if (input$dep.rnai.sel) {
          res <- res[!res$DepMap_RNAi_Selective,]
        }
      }
      
      .make_volcano(res = res,
                    xlim = isolate(input$vol.x),
                    ylim = isolate(input$vol.y),
                    fc.thresh = isolate(input$gene.lfc.th),
                    fc.lines = isolate(input$vol.fcline),
                    sig.thresh = isolate(input$gene.fdr.th),
                    sig.line = isolate(input$vol.sigline),
                    h.id = h.id,
                    h.id.suffix = "_volc2",
                    sig.term = "FDR",
                    lfc.term = "LFC",
                    feat.term = "id",
                    hover.info = c("hit_type", "goodsgrna"),
                    fs = clicked$volc2,
                    up.color = isolate(input$vol.up.color),
                    down.color = isolate(input$vol.down.color),
                    insig.color = isolate(input$vol.insig.color),
                    sig.opacity = isolate(input$vol.sig.opa),
                    insig.opacity = isolate(input$vol.insig.opa),
                    sig.size = isolate(input$vol.sig.size),
                    insig.size = isolate(input$vol.insig.size),
                    label.size = isolate(input$vol.lab.size),
                    webgl = isolate(input$vol.webgl),
                    webgl.ratio = isolate(input$vol.webgl.ratio),
                    show.counts = isolate(input$vol.counts),
                    show.hl.counts = isolate(input$vol.hl.counts),
                    counts.size = isolate(input$vol.counts.size),
                    highlight.featsets = isolate(input$hl.genesets),
                    highlight.feat = isolate(input$hl.genes),
                    featsets = genesets,
                    highlight.feats.color = isolate(input$hl.genes.col),
                    highlight.feats.size = isolate(input$hl.genes.size),
                    highlight.feats.opac = isolate(input$hl.genes.opa),
                    highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                    highlight.feats.linewidth = isolate(input$hl.genes.lw),
                    highlight.featsets.color = isolate(input$hl.genesets.col),
                    highlight.featsets.size = isolate(input$hl.genesets.size),
                    highlight.featsets.opac = isolate(input$hl.genesets.opa),
                    highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                    highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
    })
    
    output$gene2.rank <- renderPlotly({
      req(set2.genes)
      input$rank.update
      
      df <- set2.genes()
      
      # Remove common essential genes if needed.
      if (input$rem.ess & !is.null(df$essential)) {
        df <- df[!df$essential,]
      }
      
      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (input$dep.crispr.ess) {
          df <- df[!df$DepMap_CRISPR_Essential,]
        }
        
        if (input$dep.crispr.sel) {
          df <- df[!df$DepMap_CRISPR_Selective,]
        }
        
        if (input$dep.rnai.ess) {
          df <- df[!df$DepMap_RNAi_Essential,]
        }
        
        if (input$dep.rnai.sel) {
          df <- df[!df$DepMap_RNAi_Selective,]
        }
      }
      
      .make_rank(df = df,
                 ylim = list(isolate(input$rank.y.min), isolate(input$rank.y.max)),
                 y.thresh = isolate(input$gene.lfc.th),
                 y.lines = isolate(input$rank.fcline),
                 sig.thresh = isolate(input$gene.fdr.th),
                 h.id = h.id,
                 h.id.suffix = "_rank2",
                 sig.term = "FDR",
                 y.term = "LFC",
                 x.term = "Rank",
                 feat.term = "id",
                 hover.info = c("hit_type", "goodsgrna"),
                 fs = clicked$rank2,
                 up.color = isolate(input$rank.up.color),
                 down.color = isolate(input$rank.down.color),
                 insig.color = isolate(input$rank.insig.color),
                 sig.opacity = isolate(input$rank.sig.opa),
                 insig.opacity = isolate(input$rank.insig.opa),
                 sig.size = isolate(input$rank.sig.size),
                 insig.size = isolate(input$rank.insig.size),
                 label.size = isolate(input$rank.lab.size),
                 webgl = isolate(input$rank.webgl),
                 webgl.ratio = isolate(input$rank.webgl.ratio),
                 show.counts = isolate(input$rank.counts),
                 show.hl.counts = isolate(input$rank.hl.counts),
                 counts.size = isolate(input$rank.counts.size),
                 highlight.featsets = isolate(input$hl.genesets),
                 highlight.feat = isolate(input$hl.genes),
                 featsets = genesets,
                 highlight.feats.color = isolate(input$hl.genes.col),
                 highlight.feats.size = isolate(input$hl.genes.size),
                 highlight.feats.opac = isolate(input$hl.genes.opa),
                 highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                 highlight.feats.linewidth = isolate(input$hl.genes.lw),
                 highlight.featsets.color = isolate(input$hl.genesets.col),
                 highlight.featsets.size = isolate(input$hl.genesets.size),
                 highlight.featsets.opac = isolate(input$hl.genesets.opa),
                 highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                 highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
    })
    
    output$gene2.lawn <- renderPlotly({
      req(set2.genes)
      df <- set2.genes()
      
      # Remove common essential genes if needed.
      if (input$rem.ess & !is.null(df$essential)) {
        df <- df[!df$essential,]
      }
      
      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (input$dep.crispr.ess) {
          df <- df[!df$DepMap_CRISPR_Essential,]
        }
        
        if (input$dep.crispr.sel) {
          df <- df[!df$DepMap_CRISPR_Selective,]
        }
        
        if (input$dep.rnai.ess) {
          df <- df[!df$DepMap_RNAi_Essential,]
        }
        
        if (input$dep.rnai.sel) {
          df <- df[!df$DepMap_RNAi_Selective,]
        }
      }
      
      .make_lawn(res = df,
                 ylim = isolate(input$lawn.y),
                 fc.thresh = isolate(input$gene.lfc.th),
                 sig.thresh = isolate(input$gene.fdr.th),
                 sig.line = isolate(input$lawn.sigline),
                 h.id = h.id,
                 h.id.suffix = "_lawn2",
                 sig.term = "FDR",
                 lfc.term = "LFC",
                 feat.term = "id",
                 x.term = "RandomIndex",
                 hover.info = c("hit_type", "goodsgrna"),
                 fs = clicked$lawn2,
                 up.color = isolate(input$lawn.up.color),
                 down.color = isolate(input$lawn.down.color),
                 insig.color = isolate(input$lawn.insig.color),
                 sig.opacity = isolate(input$lawn.sig.opa),
                 insig.opacity = isolate(input$lawn.insig.opa),
                 sig.size = isolate(input$lawn.sig.size),
                 insig.size = isolate(input$lawn.insig.size),
                 label.size = isolate(input$lawn.lab.size),
                 webgl = isolate(input$lawn.webgl),
                 webgl.ratio = isolate(input$lawn.webgl.ratio),
                 show.counts = isolate(input$lawn.counts),
                 show.hl.counts = isolate(input$lawn.hl.counts),
                 counts.size = isolate(input$lawn.counts.size),
                 highlight.featsets = isolate(input$hl.genesets),
                 highlight.feat = isolate(input$hl.genes),
                 featsets = genesets,
                 highlight.feats.color = isolate(input$hl.genes.col),
                 highlight.feats.size = isolate(input$hl.genes.size),
                 highlight.feats.opac = isolate(input$hl.genes.opa),
                 highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                 highlight.feats.linewidth = isolate(input$hl.genes.lw),
                 highlight.featsets.color = isolate(input$hl.genesets.col),
                 highlight.featsets.size = isolate(input$hl.genesets.size),
                 highlight.featsets.opac = isolate(input$hl.genesets.opa),
                 highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                 highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
    })
    
    # Initialize plots by simulating button click once.
    o <- observe({
      req(pc, input$dim1, input$dim2, input$dim3)
      shinyjs::click("pca.update")
      o$destroy
    })
  }
  
  shinyApp(ui, server, options = list(height = height))
}
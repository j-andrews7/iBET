#' Create an interactive Shiny app for visualization & exploration of MAGeCK RRA CRISPR analyses
#'
#' This shiny app is composed of multiple tabs to peruse RRA results and compare them between timepoints or samples.
#' Also included are numerous QC plots. Almost all plots are interactive and their aesthetics can be easily tweaked
#' using the sidebar. See the Details section for more information.
#'
#' Gene labels can be added to the MAplot and volcano plot by clicking a point. The labels can also be dragged around,
#' though adding labels will reset the positions, so it's recommended to add all labels prior to re-positioning them.
#'
#' @details Features with no variation will be removed prior to \code{\link[PCAtools]{pca}} being run for the PCA visualization.
#'
#' @rawNamespace import(shiny, except = c(dataTableOutput, renderDataTable))
#' @importFrom ComplexHeatmap Heatmap pheatmap
#' @import DT
#' @importFrom plotly ggplotly plotlyOutput renderPlotly toWebGL plot_ly layout add_annotations config toRGB event_data
#' @import ggplot2
#' @importFrom shinyWidgets prettyCheckbox dropdownButton tooltipOptions
#' @importFrom shinycssloaders withSpinner
#' @importFrom shinyjqui jqui_resizable
#' @importFrom shinyjs show useShinyjs hidden disable click
#' @importFrom colourpicker colourInput
#' @importFrom MAGeCKFlute BarView MapRatesView VolcanoView ScatterView
#' @importFrom PCAtools pca
#' @importFrom dittoSeq dittoColors
#' @importFrom grid grid.newpage grid.text
#' @importFrom matrixStats rowVars rowMaxs rowMins
#' @importFrom graphics hist legend lines
#' @importFrom stats cor
#' @importFrom utils read.csv
#'
#' @param gene.data A named list containing \code{gene_summary.txt} tables as data.frames. Multiple data.frames may be provided, one per element of the list.
#'   Users will be able to swap between them within the app. List element names should match names of \code{grna.data} list elements.
#' @param sgrna.data A named list containing \code{sgrna_summary.txt} tables as data.frames. Multiple data.frames may be provided, one per element of the list.
#'   Users will be able to swap between them within the app. List element names should match names of \code{gene.data} list elements.
#' @param count.summary Matrix or dataframe containing count summary (\code{countsummary.txt}) as generated by \code{mageck count}.
#' @param norm.counts Matrix or dataframe containing normalized counts (\code{count_normalized.txt}) as generated by \code{mageck count}.
#' @param h.id String indicating unique ID for interactive plots.
#'   Required if multiple apps are run within the same Rmd file.
#' @param use.depmap.essential Boolean indicating whether to download and use DepMap CRISPR and RNAi gene dependency summaries for selective and common essential labeling.
#' @param essential.genes Optional character vector of gene identifiers of common essential genes (i.e. pan-lethal) that can be used for labeling/filtering plots.
#'   If provided, overrides the depmap essential genes.
#' @param depmap.data Optional named list containing depmap data.
#' @param genesets Optional named list containing genesets that can be interactively highlighted on the plots.
#'   The elements of the list should each be a geneset with gene identifiers matching those used in the results.
#' @param return.app Optional boolean indicating whether a Shiny app should be returned. \code{TRUE} by default. If \code{FALSE},
#'   a named list of app elements (ui and server) will be returned instead. Useful for deploying as a standalone shiny app.
#' @param height Number indicating height of app in pixels.
#'
#' @return A Shiny app containing interactive visualizations of MAGeCK RRA analysis results.
#'
#'
#' @seealso
#' \code{\link[DESeq2]{results}}, \code{\link[DESeq2]{lfcShrink}}, \code{\link[DESeq2]{resultsNames}}.
#'
#' @author Jared Andrews
#' @export
shinyMAGeCK <- function(gene.data, sgrna.data, count.summary, norm.counts, h.id = "mag1", use.depmap.essential = TRUE,
                        essential.genes = NULL, depmap.data = NULL, genesets = NULL, return.app = TRUE, height = 800) {

  # Retrieve depmap data.
  if (use.depmap.essential) {
    depmap.gene <- tryCatch(
      {
        depmap.gene <- read.csv("https://depmap.org/portal/api/download/gene_dep_summary")
      },
      error = function(cond) {
        message("DepMap URL does not exist: https://depmap.org/portal/api/download/gene_dep_summary")
        message(cond)
        message("Continuing without DepMap dependency summaries.")
        return(NULL)
      }
    )
  } else {
    depmap.gene <- NULL
  }

  ui <- navbarPage(
    "shinyMAGeCK",
    useShinyjs(),
    tags$head(
      # Note the wrapping of the string in HTML()
      tags$style(HTML("
          .panel-body {
            padding: 5px;
          }
          .form-group {
            margin-bottom: 3px;
            padding-bottom: 2px !important;
            padding-top: 2px !important;
            font-size: 10px;
            line-height: 1.1;
          }
          .well {
            padding: 5px;
            margin-bottom: 10px;
          }
          .form-control, .selectize-input {
            padding-bottom: 2px !important;
            padding-top: 2px !important;
            font-size: 10px;
            height: 24px;
            min-height: 24px;
            line-height: 1.1;
          }
          .control-label {
            font-size: 10px;
            margin-bottom: 2px;
          }
          .panel-heading {
            padding: 5px 10px;
          }
          .selectize-control {
            margin-bottom: 0px;
          }
          body {
            line-height: 1.1;
          }
          hr{
            margin-top: 3px;
            margin-bottom: 3px;
          }
          .panel-group {
            margin-bottom: 8px;
          }
        "))
    ),
    tabPanel("QC",
             sidebarLayout(
               sidebarPanel(
                 width = 2,
                 h4("Plot Controls"),
                 hr(),
                 bsCollapse(open = "pca.settings",
                            bsCollapsePanel(
                              title = span(icon("plus"), "PCA Settings"), value = "pca.settings", style = "info",
                              uiOutput("pca.comps"),
                              conditionalPanel(
                                condition = "input['keep.top.n'] == false",
                                numericInput("var.remove", "Remove this proportion of features ranked by variance:",
                                             min = 0, max = 1, step = 0.01, value = 0)
                              ),
                              conditionalPanel(
                                condition = "input['keep.top.n'] == true",
                                numericInput("var.n.keep", "Number of features to retain by variance:",
                                             min = 2, max = Inf, step = 1, value = 500)
                              ),
                              fluidRow(
                                column(6,
                                       prettyCheckbox("center", strong("Center data"), TRUE, bigger = FALSE,
                                                      animation = "smooth", status = "success",
                                                      icon = icon("check"), width = "100%"),
                                       prettyCheckbox("keep.top.n", strong("Limit by top N features"), FALSE, bigger = FALSE,
                                                      animation = "smooth", status = "success",
                                                      icon = icon("check"), width = "100%")
                                ),
                                column(6,
                                       prettyCheckbox("scale", strong("Scale data"), TRUE, bigger = FALSE,
                                                      animation = "smooth", status = "success",
                                                      icon = icon("check"), width = "100%")
                                )
                              ),
                              prettyCheckbox("meta.filt", strong("Filter via metadata table"), TRUE, bigger = FALSE,
                                             animation = "smooth", status = "success",
                                             icon = icon("check"), width = "100%"),
                              fluidRow(
                                column(6, selectInput("bip.color", "Color by:",
                                                      choices = c("", colnames(count.summary)), selected = "Label")),
                                column(6, selectInput("bip.shape", "Shape by:",
                                                      choices = c("", colnames(count.summary))))
                              ),
                              fluidRow(
                                column(6,
                                       prettyCheckbox("bip.twod", strong("Limit to 2D"), TRUE, bigger = FALSE,
                                                      animation = "smooth", status = "success",
                                                      icon = icon("check"), width = "100%")
                                ),
                                column(6,
                                       prettyCheckbox("bip.loadings", strong("Plot Loadings"), FALSE, bigger = FALSE,
                                                      animation = "smooth", status = "success",
                                                      icon = icon("check"), width = "100%")
                                )
                              ),
                              numericInput("bip.n.loadings", "Loadings:",
                                           min = 0, max = 100, step = 1, value = 5),
                              div(actionButton("pca.update", "Update PCA"), align = "center")
                            )
                 )
               ),
               mainPanel(
                 width = 10,
                 fluidRow(
                   column(width = 4,
                          jqui_resizable(plotlyOutput("qc.gini")),
                          jqui_resizable(plotOutput("qc.histplot"))
                   ),
                   column(width = 4,
                          jqui_resizable(plotlyOutput("qc.missed")),
                          jqui_resizable(plotOutput("qc.corr"))
                   ),
                   column(width = 4,
                          jqui_resizable(plotOutput("qc.map")),
                          withSpinner(jqui_resizable(plotlyOutput("qc.pca")))
                   )
                 )
               )
             )
    ),
    tabPanel("QC Table",
             br(),
             DTOutput("count.summary")
    ),
    tabPanel("Gene (Overview)",
             sidebarLayout(
               sidebarPanel(
                 width = 2,
                 h4("Plot Controls"),
                 hr(),
                 div(
                   fluidRow(
                     column(6,
                        selectInput("gene.sel1", "Dataset 1:", choices = names(gene.data)),
                        numericInput("gene.fdr.th", "FDR threshold:",
                                     min = 0, max = 1, step = 0.01, value = 0.05)
                     ),
                     column(6,
                        selectInput("gene.sel2", "Dataset 2:", choices = names(gene.data),
                                    selected = ifelse(length(names(gene.data) > 1), names(gene.data)[2], names(gene.data)[1])),
                        numericInput("gene.lfc.th", "log2FC threshold:",
                                     min = 0, max = Inf, step = 0.05, value = 0.5)
                     )
                   ),
                   fluidRow(
                     column(12,
                       prettyCheckbox("rem.ess", label = "Remove essential genes", value = FALSE,
                         animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                       prettyCheckbox("dep.crispr.ess", label = "Remove DepMap CRISPR essential genes", value = FALSE,
                                      animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                       prettyCheckbox("dep.rnai.ess", label = "Remove DepMap RNAi essential genes", value = FALSE,
                                      animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                       prettyCheckbox("dep.crispr.sel", label = "Remove DepMap CRISPR selective genes", value = FALSE,
                                      animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                       prettyCheckbox("dep.rnai.sel", label = "Remove DepMap RNAi selective genes", value = FALSE,
                                      animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                       prettyCheckbox("highlight.common", label = "Highlight common hits", value = FALSE,
                                      animation = "smooth", status = "success", bigger = TRUE, icon = icon("check"))
                     )
                   ),
                 style = "background-color: #FFFFFF; padding: 3px; margin-bottom: 3px; border: 1px solid #bce8f1; "),
                 bsCollapse(open = NULL,
                    bsCollapsePanel(
                      title = span(icon("plus"), "Common Plot Settings"), value = "com.settings", style = "info",
                      fluidRow(
                        column(width = 6,
                               colourInput("down.color", "Down colour", value = "#0026ff"),
                               colourInput("up.color", "Up colour", value = "red"),
                               colourInput("insig.color", "Insig colour", value = "#A6A6A6"),
                               numericInput("sig.opa", label = "Sig opacity:", value = 1, step = 0.05, min = 0)
                        ),
                        column(width = 6,
                               numericInput("sig.size", label = "Sig pt size:", value = 6, step = 0.1, min = 0),
                               numericInput("lab.size", label = "Label size:", value = 10, step = 0.5, min = 1),
                               numericInput("insig.opa", label = "Insig opacity:", value = 0.5, step = 0.05, min = 0),
                               numericInput("insig.size", label = "Insig pt size:", value = 5, step = 0.1, min = 0)
                        )
                      ),
                      splitLayout(
                        prettyCheckbox("counts", label = "Show counts", TRUE, bigger = TRUE,
                                       animation = "smooth", status = "success",
                                       icon = icon("check"), width = "100%"),
                        prettyCheckbox("webgl", label = "Use webGL", FALSE, bigger = TRUE,
                                       animation = "smooth", status = "success",
                                       icon = icon("check"), width = "100%")
                      ),
                      splitLayout(
                        prettyCheckbox("hl.counts", label = "Show highlight counts", FALSE, bigger = TRUE,
                                       animation = "smooth", status = "success",
                                       icon = icon("check"), width = "100%")
                      ),
                      splitLayout(
                        numericInput("counts.size", label = "Counts size:", value = 8, step = 0.1, min = 0),
                        numericInput("webgl.ratio", label = "webGL pixel ratio:", value = 7, step = 0.1, min = 1)
                      )
                    ),
                    bsCollapsePanel(
                      title = span(icon("plus"), "Volcano Plot Settings"), value = "vol.settings", style = "info",
                      fluidRow(
                        column(width = 6,
                               numericInput("vol.x", label = "x-axis limits:", value = 5, step = 0.1, min = 0.1)
                        ),
                        column(width = 6,
                               numericInput("vol.y", label = "y-axis limits:", value = 5, step = 0.5, min = 1)
                        )
                      ),
                      splitLayout(
                        prettyCheckbox("vol.fcline", label = "Show FC threshold", value = TRUE,
                                       animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                        prettyCheckbox("vol.sigline", label = "Show Sig. threshold", value = TRUE,
                                       animation = "smooth", status = "success", bigger = TRUE, icon = icon("check"))
                      ),
                      div(actionButton("vol.update", "Update Volcano Plots"), align = "center")
                    ),
                    bsCollapsePanel(
                      title = span(icon("plus"), "Rank Plot Settings"), value = "rank.settings", style = "info",
                      fluidRow(
                        column(width = 6,
                               numericInput("rank.y.max", label = "y-axis max:", value = 2, step = 0.5),
                               prettyCheckbox("rank.fcline", label = "Show FC threshold", value = TRUE,
                                              animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                        ),
                        column(width = 6,
                               numericInput("rank.y.min", label = "y-axis min:", value = -10, step = 0.5, min = 1),
                        )
                      ),
                      div(actionButton("rank.update", "Update Rank Plots"), align = "center")
                    ),
                    bsCollapsePanel(
                      title = span(icon("plus"), "Lawn Plot Settings"), value = "lawn.settings", style = "info",
                      splitLayout(
                        prettyCheckbox("lawn.sigline", label = "Show Sig. threshold", value = TRUE,
                                       animation = "smooth", status = "success", bigger = TRUE, icon = icon("check")),
                        numericInput("lawn.y", label = "y-axis limits:", value = 5, step = 0.5, min = 1)
                      ),
                      div(actionButton("lawn.update", "Update Lawn Plots"), align = "center")
                    ),
                    bsCollapsePanel(title = span(icon("plus"), "Highlight Gene(sets)"), style = "info",
                      textAreaInput("hl.genes", "Highlight Genes:", value = "", rows = 4,
                                    placeholder = "Enter space, comma, or newline delimited genes"),
                      pickerInput("hl.genesets", "Highlight Genesets:", choices = c("", names(genesets)),
                                  multiple = TRUE, options = list(`live-search` = TRUE,
                                                                  `actions-box` = TRUE)),
                      fluidRow(
                        column(6,
                               numericInput("hl.genes.opa", label = "Genes opacity:", value = 1, step = 0.05, min = 0),
                               numericInput("hl.genes.size", label = "Genes pt size:", value = 7, step = 0.1, min = 0),
                               numericInput("hl.genes.lw", label = "Genes border width:", value = 1, step = 0.05, min = 0),
                               colourInput("hl.genes.col", "Genes color:", value = "#E69F00"),
                               colourInput("hl.genes.lcol", "Genes border:", value = "#000000")),
                        column(6,
                               numericInput("hl.genesets.opa", label = "Sets opacity:", value = 1, step = 0.05, min = 0),
                               numericInput("hl.genesets.size", label = "Sets pt size:", value = 7, step = 0.1, min = 0),
                               numericInput("hl.genesets.lw", label = "Sets border width:", value = 1, step = 0.05, min = 0),
                               colourInput("hl.genesets.col", "Sets color:", value = "#009E73"),
                               colourInput("hl.genesets.lcol", "Sets border:", value = "#000000"))
                      )
                    )
                 ),
                 div(actionButton("gene.update", "Update Plots"), align = "center")
               ),
               mainPanel(
                 width = 10,
                 fluidRow(
                   column(width = 4,
                          withSpinner(jqui_resizable(plotlyOutput("gene1.vol")))
                   ),
                   column(width = 4,
                          withSpinner(jqui_resizable(plotlyOutput("gene1.rank")))
                   ),
                   column(width = 4,
                          withSpinner(jqui_resizable(plotlyOutput("gene1.lawn")))
                   )
                 ),
                 hr(),
                 fluidRow(
                   column(width = 4,
                          withSpinner(jqui_resizable(plotlyOutput("gene2.vol")))
                   ),
                   column(width = 4,
                          withSpinner(jqui_resizable(plotlyOutput("gene2.rank")))
                   ),
                   column(width = 4,
                          withSpinner(jqui_resizable(plotlyOutput("gene2.lawn")))
                   )
                 )
               )
             )
    ),
    tabPanel("Gene Summary Tables",
             br(),
             div(DT::dataTableOutput("gene1.summary"), style = "font-size:80%;"),
             br(),
             div(DT::dataTableOutput("gene2.summary"), style = "font-size:80%;")
    ),
    tabPanel("sgRNA",
             sidebarLayout(
               sidebarPanel(
                 width = 2,
                 h4("Plot Controls"),
                 hr(),
                 div(
                   fluidRow(
                     column(6,
                            selectInput("sgrna.sel1", "Dataset 1:", choices = names(sgrna.data))
                     ),
                     column(6,
                            selectInput("sgrna.sel2", "Dataset 2:", choices = names(sgrna.data),
                                        selected = ifelse(length(names(sgrna.data) > 1), names(sgrna.data)[2], names(sgrna.data)[1]))
                     )
                   ),
                   fluidRow(
                     column(12,
                            pickerInput("sgrna.gene", "Choose gene:", choices = unique(c(sgrna.data[[1]]$Gene)),
                                        multiple = FALSE, options = list(`live-search` = TRUE, `actions-box` = TRUE))
                     )
                   ),
                   style = "background-color: #FFFFFF; padding: 3px; margin-bottom: 3px; border: 1px solid #bce8f1; "),

               ),
               mainPanel(
                 width = 10,
                 fluidRow(
                   column(width = 2,
                          withSpinner(jqui_resizable(plotlyOutput("sgrna1.counts")))
                   ),
                   column(width = 4,
                          withSpinner(jqui_resizable(plotlyOutput("sgrna1.rank")))
                   ),
                   column(width = 6,
                          jqui_resizable(div(DT::dataTableOutput("sgrna1.detail"), style = "font-size:80%;"))
                   )
                 ),
                 hr(),
                 fluidRow(
                   column(width = 2,
                          withSpinner(jqui_resizable(plotlyOutput("sgrna2.counts")))
                   ),
                   column(width = 4,
                          withSpinner(jqui_resizable(plotlyOutput("sgrna2.rank")))
                   ),
                   column(width = 6,
                          jqui_resizable(div(DT::dataTableOutput("sgrna2.detail"), style = "font-size:80%;"))
                   )
                 )
               )
             )
    ),
    tabPanel("sgRNA Summary Tables",
             br(),
             div(DT::dataTableOutput("sgrna1.summary"), style = "font-size:80%;"),
             br(),
             div(DT::dataTableOutput("sgrna2.summary"), style = "font-size:80%;")
    )
  )

  server <- function(input, output, session) {

    # -----------QC & QC Summary Tabs------------
    # PCA.
    pc <- reactive({
      slmed <- norm.counts
      slmat <- as.matrix(slmed[,c(-1,-2)])
      mat <- log2(slmat+1)
      rownames(mat) <- slmed$sgRNA

      req(input$var.remove)
      meta <- count.summary

      # Filter samples from QC table.
      if (!is.null(input$count.summary_rows_all) & input$meta.filt) {
        meta <- count.summary[input$count.summary_rows_all,]
        mat <- mat[,input$count.summary_rows_all]
      }

      rownames(meta) <- gsub("-", ".", meta$Label)

      # Remove guides with no variance in counts, as they break the PCA.
      mat <- mat[(rowMaxs(mat) - rowMins(mat) > 0),]

      # If input to use top N features instead rather than percent-based feature removal, account for that
      if (input$keep.top.n) {
        mat <- mat[order(rowVars(mat), decreasing = TRUE),]
        mat <- mat[1:input$var.n.keep,]
        var.remove <- 0
      } else {
        var.remove <- input$var.remove
      }

      if (ncol(mat) > 1) {
        pca(mat, metadata = meta, removeVar = var.remove, scale = input$scale, center = input$center)
      } else {
        NULL
      }
    })

    # Populate UI with all PCs.
    # TODO: Write check for only 2 PCs.
    output$pca.comps <- renderUI({
      req(pc)
      local({
        pcs <- pc()

        tagList(
          fluidRow(
            column(4, selectInput("dim1", "Dim1:", choices = pcs$components, selected = "PC1")),
            column(4, selectInput("dim2", "Dim2:", choices = pcs$components, selected = "PC2")),
            column(4, selectInput("dim3", "Dim3:", choices = pcs$components, selected = "PC3"))
          )
        )
      })
    })

    output$qc.gini <- renderPlotly({
      gg <- BarView(count.summary, x = "Label", y = "GiniIndex",
                    ylab = "Gini index", main = "sgRNA Read Distribution")

      gg + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 12),
                 axis.text.y = element_text(size = 12))

      ggplotly(gg, tooltip = c("y")) %>%
        layout(yaxis = list(range = list(0, max(count.summary$GiniIndex) + .05)),
               xaxis = list(tickangle = 315))
    })

    output$qc.missed <- renderPlotly({
      gg <- BarView(count.summary, x = "Label", y = "Zerocounts", fill = "#394E80",
                    ylab = "Zero Count sgRNAs", main = "Fully Depleted sgRNAs")

      gg + theme_classic() + theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 12),
                                   axis.text.y = element_text(size = 12)) + ylim(0, max(count.summary$Zerocounts) + 5)

      ggplotly(gg, tooltip = c("y")) %>%
        layout(yaxis = list(range = list(0, max(count.summary$Zerocounts) + 5)),
               xaxis = list(tickangle = 315))
    })

    output$qc.map <- renderPlot({
      MapRatesView(count.summary)
    })

    # TODO: rewrite this.
    output$qc.histplot <- renderPlot({
      colors <- dittoColors()

      slmed <- norm.counts
      tabsmat <- as.matrix(log2(slmed[,c(-1,-2)] + 1))
      colnames(tabsmat) <- colnames(slmed)[c(-1,-2)]
      samplecol <- colors[((1:ncol(tabsmat)) %% length(colors)) ]
      tgz <- hist(tabsmat, breaks = 40)
      if(ncol(tabsmat) >= 1) {
        histlist <- lapply(1:ncol(tabsmat), function(X) { return (hist(tabsmat[,X], plot=FALSE, breaks=tgz$breaks)) })
        xrange <- range(unlist(lapply(histlist, function(X) {X$mids})))
        yrange <- range(unlist(lapply(histlist, function(X) {X$counts})))
        hst1 <- histlist[[1]]
        plot(hst1$mids,hst1$counts, type='b', pch=20, xlim=c(0,xrange[2]*1.2),
             ylim=c(0,yrange[2]*1.2), xlab='log2(counts)', ylab='Frequency',
             main='Distribution of read counts', col = samplecol[1])
      }
      if(ncol(tabsmat) >= 2){
        for(i in 2:ncol(tabsmat)){
          hstn <- histlist[[i]]
          lines(hstn$mids, hstn$counts, type='b', pch=20, col=samplecol[i])
        }
      }
      legend('topright', colnames(tabsmat), pch=20, lwd=1, col=samplecol)
    })

    # TODO: rewrite this, add color min/max/mid selectors.
    output$qc.corr <- renderPlot({
      slmed <- norm.counts
      slmat <- as.matrix(slmed[,c(-1,-2)])
      slmat.log <- log2(slmat+1)

      if (ncol(slmat.log) > 1){
        ComplexHeatmap::pheatmap(cor(slmat.log),
                                 heatmap_legend_param = list(title = "Pearson\nCorr."), main = "Correlation Matrix")
      } else {
        grid.newpage()
        grid.text("Only one sample, no correlation possible.")
      }
    })

    # TODO: rewrite this, add inputs.
    output$qc.pca <- renderPlotly({
      req(pc, input$dim1, input$dim2, input$dim3)
      input$pca.update

      pc.res <- isolate(pc())

      pl.cols <- NULL
      pl.shapes <- NULL
      pl.col <- "black"
      hov.text <- NULL

      # Get marker aesthetics mappings.
      # Drop unused factor levels if possible.
      if (isolate(input$bip.color) != "") {
        pl.cols <- pc.res$metadata[,isolate(input$bip.color), drop = TRUE]
        if (is.factor(pl.cols)) {
          pl.cols <- droplevels(pl.cols)
        }
        pl.col <- dittoColors()[seq_along(unique(pc.res$metadata[,isolate(input$bip.color), drop = TRUE]))]
      }

      if (isolate(input$bip.shape) != "") {
        pl.shapes <- pc.res$metadata[,isolate(input$bip.shape), drop = TRUE]
        if (is.factor(pl.shapes)) {
          pl.shapes <- droplevels(pl.shapes)
        }
      }

      # Just throw label on hover for now.
      hov.text <- paste0("</br><b>Label:</b> ", pc.res$metadata$Label)

      # Check if 2D is wanted.
      if (isolate(input$bip.twod)) {
        fig <- plot_ly(pc.res$rotated, x = as.formula(paste0("~", isolate(input$dim1))),
                       y = as.formula(paste0("~", isolate(input$dim2))),
                       type = "scatter",
                       mode = "markers",
                       marker = list(size = 15),
                       color = pl.cols,
                       colors = pl.col,
                       symbol = pl.shapes,
                       symbols = c("circle", "square", "diamond", "cross",
                                   "diamond-open", "circle-open", "square-open", "x"),
                       text = hov.text,
                       hoverinfo = "text") %>%
          layout(xaxis = list(showgrid = FALSE, showline = TRUE, mirror = TRUE, zeroline = FALSE,
                              title = paste0(isolate(input$dim1),
                                             " (", format(round(pc.res$variance[isolate(input$dim1)], 2), nsmall = 2),"%)")),
                 yaxis = list(showgrid = FALSE, showline = TRUE, mirror = TRUE, zeroline = FALSE,
                              title = paste0(isolate(input$dim2),
                                             " (", format(round(pc.res$variance[isolate(input$dim2)], 2), nsmall = 2),"%)")))

        fig <- fig %>% toWebGL()

        # Plot loadings.
        if (isolate(input$bip.loadings)) {
          lengthLoadingsArrowsFactor <- 1.5

          # Get number of loadings to display.
          xidx <- order(abs(pc.res$loadings[,isolate(input$dim1)]), decreasing = TRUE)
          yidx <- order(abs(pc.res$loadings[,isolate(input$dim2)]), decreasing = TRUE)
          vars <- unique(c(
            rownames(pc.res$loadings)[xidx][seq_len(isolate(input$bip.n.loadings))],
            rownames(pc.res$loadings)[yidx][seq_len(isolate(input$bip.n.loadings))]))

          # get scaling parameter to match between variable loadings and rotated loadings
          # This is cribbed almost verbatim from PCAtools code.
          r <- min(
            (max(pc.res$rotated[,isolate(input$dim1)]) - min(pc.res$rotated[,isolate(input$dim1)]) /
               (max(pc.res$loadings[,isolate(input$dim1)]) - min(pc.res$loadings[,isolate(input$dim1)]))),
            (max(pc.res$rotated[,isolate(input$dim2)]) - min(pc.res$rotated[,isolate(input$dim2)]) /
               (max(pc.res$loadings[,isolate(input$dim2)]) - min(pc.res$loadings[,isolate(input$dim2)]))))

          fig <- fig %>%
            add_segments(x = 0, xend = pc.res$loadings[vars,isolate(input$dim1)] * r * lengthLoadingsArrowsFactor,
                         y = 0, yend = pc.res$loadings[vars,isolate(input$dim2)] * r * lengthLoadingsArrowsFactor,
                         line = list(color = 'black'), inherit = FALSE, showlegend = FALSE, hoverinfo = "text") %>%
            add_annotations(x = pc.res$loadings[vars,isolate(input$dim1)] * r * lengthLoadingsArrowsFactor,
                            y = pc.res$loadings[vars,isolate(input$dim2)] * r * lengthLoadingsArrowsFactor,
                            ax = 0, ay = 0, text = vars, xanchor = 'center', yanchor= 'bottom')
        }
      } else {

        # Generate plot.
        fig <- plot_ly(pc.res$rotated, x = as.formula(paste0("~", isolate(input$dim1))),
                       y = as.formula(paste0("~", isolate(input$dim2))),
                       z = as.formula(paste0("~", isolate(input$dim3))),
                       type = "scatter3d",
                       mode = "markers",
                       color = pl.cols,
                       colors = pl.col,
                       symbol = pl.shapes,
                       symbols = c("circle", "square", "diamond", "cross", "diamond-open",
                                   "circle-open", "square-open", "x"),
                       text = hov.text,
                       hoverinfo = "text") %>%
          layout(scene = list(
            xaxis = list(title = paste0(isolate(input$dim1), " (",
                                        format(round(pc.res$variance[isolate(input$dim1)], 2), nsmall = 2),"%)")),
            yaxis = list(title = paste0(isolate(input$dim2), " (",
                                        format(round(pc.res$variance[isolate(input$dim2)], 2), nsmall = 2),"%)")),
            zaxis = list(title = paste0(isolate(input$dim3), " (",
                                        format(round(pc.res$variance[isolate(input$dim3)], 2), nsmall = 2),"%)")),
            camera = list(eye = list(x=1.5, y = 1.8, z = 0.4))))
      }
      fig <- fig %>%
        config(edits = list(annotationPosition = TRUE,
                            annotationTail = FALSE),
               toImageButtonOptions = list(format = "svg"),
               displaylogo = FALSE,
               plotGlPixelRatio = 7)

      fig
    })

    output$count.summary <- renderDT({
      DT::datatable(count.summary,
                    rownames = FALSE,
                    filter = "top",
                    extensions = c("Buttons", "Scroller"),
                    options = list(
                      search = list(regex = TRUE),
                      lengthMenu = list(c(10, 25, 50, -1), c("10", "25", "50", "all")),
                      dom = 'Blfrtip',
                      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                      scrollX = TRUE,
                      deferRender = TRUE,
                      scrollY = 600,
                      scroller = TRUE)
      ) %>% DT::formatStyle(0, target = "row", lineHeight = '80%')
    })

    # Initialize plots by simulating button click once.
    o <- observe({
      req(pc, input$dim1, input$dim2, input$dim3)
      shinyjs::click("pca.update")
      o$destroy
    })

    #---------Gene (Overview) & Summary Tables Tabs-------------

    # Remove certain outputs if parameters for them are not provided.
    if (!use.depmap.essential) {
      shinyjs::hide("dep.crispr.ess")
      shinyjs::hide("dep.crispr.sel")
      shinyjs::hide("dep.rnai.ess")
      shinyjs::hide("dep.rnai.sel")
    }

    if (is.null(essential.genes)) {
      shinyjs::hide("rem.ess")
    }

    # Disable certain inputs if only one dataset provided.
    if (length(gene.data) == 1) {
      shinyjs::disable("gene.sel2")
      shinyjs::hide("highlight.common")
    }

    # Load the gene summaries for easy plotting.
    set1.genes <- reactive({
      df <- gene.data[[input$gene.sel1]]
      .gene_ingress(df, sig.thresh = input$gene.fdr.th, lfc.thresh = input$gene.lfc.th, essential.genes = essential.genes, depmap.genes = depmap.gene)
    })

    if (length(gene.data) > 1) {
      set2.genes <- reactive({
        df <- gene.data[[input$gene.sel2]]
        .gene_ingress(df, sig.thresh = input$gene.fdr.th, lfc.thresh = input$gene.lfc.th, essential.genes = essential.genes, depmap.genes = depmap.gene)
      })
    }

    # Get overlapping hits between sets if needed.
    common.hits <- reactive({
      req(set1.genes, set2.genes)
      s1 <- set1.genes()
      s2 <- set2.genes()

      set1.hits <- s1$id[s1$hit_type %in% c("neg", "pos")]
      set2.hits <- s2$id[s2$hit_type %in% c("neg", "pos")]

      set1.hits[set1.hits %in% set2.hits]
    })

    # Keep track of which genes have been clicked
    clicked <- reactiveValues(volc1 = NULL, rank1 = NULL, lawn1 = NULL, volc2 = NULL, rank2 = NULL, lawn2 = NULL)

    # On click, the key field of the event data contains the gene symbol.
    # Add that gene to the set of all "selected" genes. Double click will clear all labels.
    # TODO: lapply this, probably.
    observeEvent(event_data("plotly_click", source = paste0(h.id,"_volc1")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_volc1"))
      gene_old_new <- rbind(clicked$volc1, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$volc1 <- NULL
      } else {
        clicked$volc1 <- keep
      }
    })

    observeEvent(event_data("plotly_click", source = paste0(h.id,"_rank1")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_rank1"))
      gene_old_new <- rbind(clicked$rank1, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$rank1 <- NULL
      } else {
        clicked$rank1 <- keep
      }
    })

    observeEvent(event_data("plotly_click", source = paste0(h.id,"_lawn1")), {
      gene <- event_data("plotly_click", source = paste0(h.id,"_lawn1"))
      gene_old_new <- rbind(clicked$lawn1, gene)
      keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

      if (nrow(keep) == 0) {
        clicked$lawn1 <- NULL
      } else {
        clicked$lawn1 <- keep
      }
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_volc1")), {
      clicked$volc1 <- NULL
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_rank1")), {
      clicked$rank1 <- NULL
    })

    observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_lawn1")), {
      clicked$lawn1 <- NULL
    })

    if (length(gene.data) > 1) {
      observeEvent(event_data("plotly_click", source = paste0(h.id,"_volc2")), {
        gene <- event_data("plotly_click", source = paste0(h.id,"_volc2"))
        gene_old_new <- rbind(clicked$volc2, gene)
        keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

        if (nrow(keep) == 0) {
          clicked$volc2 <- NULL
        } else {
          clicked$volc2 <- keep
        }
      })

      observeEvent(event_data("plotly_click", source = paste0(h.id,"_rank2")), {
        gene <- event_data("plotly_click", source = paste0(h.id,"_rank2"))
        gene_old_new <- rbind(clicked$rank2, gene)
        keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

        if (nrow(keep) == 0) {
          clicked$rank2 <- NULL
        } else {
          clicked$rank2 <- keep
        }
      })

      observeEvent(event_data("plotly_click", source = paste0(h.id,"_lawn2")), {
        gene <- event_data("plotly_click", source = paste0(h.id,"_lawn2"))
        gene_old_new <- rbind(clicked$lawn2, gene)
        keep <- gene_old_new[gene_old_new$customdata %in% names(which(table(gene_old_new$customdata)==1)),]

        if (nrow(keep) == 0) {
          clicked$lawn2 <- NULL
        } else {
          clicked$lawn2 <- keep
        }
      })

      observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_volc2")), {
        clicked$volc2 <- NULL
      })

      observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_rank2")), {
        clicked$rank2 <- NULL
      })

      observeEvent(event_data("plotly_doubleclick", source = paste0(h.id,"_lawn2")), {
        clicked$lawn2 <- NULL
      })
    }

    # Summary table and plots.
    output$gene1.summary <- renderDT({
      req(set1.genes)
      # Remove columns that are redundant or confusing.
      target <- which(names(set1.genes()) %in% c("neg|score", "neg|p-value", "neg|rank",
                                                 "neg|lfc", "pos|score", "pos|p-value", "pos|rank",
                                                 "pos|lfc", "RandomIndex", "Rank", "goodsgrna")) - 1

      df <- set1.genes()

      if (!is.null(common.hits())) {
        df$Overlap <- df$id %in% common.hits()
      }

      DT::datatable(df,
                    rownames = FALSE,
                    filter = "top",
                    extensions = c("Buttons"),
                    caption = paste0(input$gene.sel1, " Gene Summary"),
                    options = list(
                      search = list(regex = TRUE),
                      pageLength = 10,
                      dom = 'Blfrtip',
                      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                      columnDefs = list(list(visible = FALSE, targets = target)))
      ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
    })

    output$gene1.vol <- renderPlotly({
      req(set1.genes)
      input$vol.update

      res <- set1.genes()

      hov.info <- c("hit_type", "num", "goodsgrna")

      # Remove common essential genes if needed.
      if (isolate(input$rem.ess) & !is.null(res$essential)) {
        res <- res[!res$essential,]
      }

      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (input$dep.crispr.ess) {
          res <- res[!res$DepMap_CRISPR_Essential,]
        }

        if (input$dep.crispr.sel) {
          res <- res[!res$DepMap_CRISPR_Selective,]
        }

        if (input$dep.rnai.ess) {
          res <- res[!res$DepMap_RNAi_Essential,]
        }

        if (input$dep.rnai.sel) {
          res <- res[!res$DepMap_RNAi_Selective,]
        }
      }

      highlight <- NULL
      if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
        highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
        highlight <- highlight.feats[highlight.feats != ""]
      }

      # Add common hits to highlight.
      if (isolate(input$highlight.common)) {
        highlight <- unique(c(common.hits(), highlight))
      }


      .make_volcano(res = res,
                    xlim = isolate(input$vol.x),
                    ylim = isolate(input$vol.y),
                    fc.thresh = isolate(input$gene.lfc.th),
                    fc.lines = isolate(input$vol.fcline),
                    sig.thresh = isolate(input$gene.fdr.th),
                    sig.line = isolate(input$vol.sigline),
                    h.id = h.id,
                    h.id.suffix = "_volc1",
                    sig.term = "FDR",
                    lfc.term = "LFC",
                    feat.term = "id",
                    hover.info = hov.info,
                    fs = clicked$volc1,
                    up.color = isolate(input$up.color),
                    down.color = isolate(input$down.color),
                    insig.color = isolate(input$insig.color),
                    sig.opacity = isolate(input$sig.opa),
                    insig.opacity = isolate(input$insig.opa),
                    sig.size = isolate(input$sig.size),
                    insig.size = isolate(input$insig.size),
                    label.size = isolate(input$lab.size),
                    webgl = isolate(input$webgl),
                    webgl.ratio = isolate(input$webgl.ratio),
                    show.counts = isolate(input$counts),
                    show.hl.counts = isolate(input$hl.counts),
                    counts.size = isolate(input$counts.size),
                    highlight.featsets = isolate(input$hl.genesets),
                    highlight.feats = highlight,
                    featsets = genesets,
                    highlight.feats.color = isolate(input$hl.genes.col),
                    highlight.feats.size = isolate(input$hl.genes.size),
                    highlight.feats.opac = isolate(input$hl.genes.opa),
                    highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                    highlight.feats.linewidth = isolate(input$hl.genes.lw),
                    highlight.featsets.color = isolate(input$hl.genesets.col),
                    highlight.featsets.size = isolate(input$hl.genesets.size),
                    highlight.featsets.opac = isolate(input$hl.genesets.opa),
                    highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                    highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
    })

    output$gene1.rank <- renderPlotly({
      req(set1.genes)
      input$rank.update

      df <- set1.genes()

      hov.info <- c("hit_type", "num", "goodsgrna")

      # Remove common essential genes if needed.
      if (input$rem.ess & !is.null(df$essential)) {
        df <- df[!df$essential,]
      }

      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (input$dep.crispr.ess) {
          df <- df[!df$DepMap_CRISPR_Essential,]
        }

        if (input$dep.crispr.sel) {
          df <- df[!df$DepMap_CRISPR_Selective,]
        }

        if (input$dep.rnai.ess) {
          df <- df[!df$DepMap_RNAi_Essential,]
        }

        if (input$dep.rnai.sel) {
          df <- df[!df$DepMap_RNAi_Selective,]
        }
      }

      highlight <- NULL
      if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
        highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
        highlight <- highlight.feats[highlight.feats != ""]
      }

      # Add common hits to highlight.
      if (isolate(input$highlight.common)) {
        highlight <- unique(c(common.hits(), highlight))
      }

      .make_rank(df = df,
                    ylim = list(isolate(input$rank.y.min), isolate(input$rank.y.max)),
                    y.thresh = isolate(input$gene.lfc.th),
                    y.lines = isolate(input$rank.fcline),
                    sig.thresh = isolate(input$gene.fdr.th),
                    h.id = h.id,
                    h.id.suffix = "_rank1",
                    sig.term = "FDR",
                    y.term = "LFC",
                 x.term = "Rank",
                    feat.term = "id",
                 hover.info = c("hit_type", "goodsgrna"),
                    fs = clicked$rank1,
                    up.color = isolate(input$up.color),
                    down.color = isolate(input$down.color),
                    insig.color = isolate(input$insig.color),
                    sig.opacity = isolate(input$sig.opa),
                    insig.opacity = isolate(input$insig.opa),
                    sig.size = isolate(input$sig.size),
                    insig.size = isolate(input$insig.size),
                    label.size = isolate(input$lab.size),
                    webgl = isolate(input$webgl),
                    webgl.ratio = isolate(input$webgl.ratio),
                    show.counts = isolate(input$counts),
                    show.hl.counts = isolate(input$hl.counts),
                    counts.size = isolate(input$counts.size),
                    highlight.featsets = isolate(input$hl.genesets),
                    highlight.feats = highlight,
                    featsets = genesets,
                    highlight.feats.color = isolate(input$hl.genes.col),
                    highlight.feats.size = isolate(input$hl.genes.size),
                    highlight.feats.opac = isolate(input$hl.genes.opa),
                    highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                    highlight.feats.linewidth = isolate(input$hl.genes.lw),
                    highlight.featsets.color = isolate(input$hl.genesets.col),
                    highlight.featsets.size = isolate(input$hl.genesets.size),
                    highlight.featsets.opac = isolate(input$hl.genesets.opa),
                    highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                    highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
    })

    output$gene1.lawn <- renderPlotly({
      req(set1.genes)
      df <- set1.genes()
      input$lawn.update

      hov.info <- c("hit_type", "num", "goodsgrna")

      # Remove common essential genes if needed.
      if (input$rem.ess & !is.null(df$essential)) {
        df <- df[!df$essential,]
      }

      # Remove DepMap stuff if requested.
      if (!is.null(depmap.gene)) {
        if (input$dep.crispr.ess) {
          df <- df[!df$DepMap_CRISPR_Essential,]
        }

        if (input$dep.crispr.sel) {
          df <- df[!df$DepMap_CRISPR_Selective,]
        }

        if (input$dep.rnai.ess) {
          df <- df[!df$DepMap_RNAi_Essential,]
        }

        if (input$dep.rnai.sel) {
          df <- df[!df$DepMap_RNAi_Selective,]
        }
      }

      highlight <- NULL
      if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
        highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
        highlight <- highlight.feats[highlight.feats != ""]
      }

      # Add common hits to highlight.
      if (isolate(input$highlight.common)) {
        highlight <- unique(c(common.hits(), highlight))
      }

      .make_lawn(res = df,
                    ylim = isolate(input$lawn.y),
                    fc.thresh = isolate(input$gene.lfc.th),
                    sig.thresh = isolate(input$gene.fdr.th),
                    sig.line = isolate(input$lawn.sigline),
                    h.id = h.id,
                    h.id.suffix = "_lawn1",
                    sig.term = "FDR",
                    lfc.term = "LFC",
                    feat.term = "id",
                 x.term = "RandomIndex",
                    hover.info = hov.info,
                    fs = clicked$lawn1,
                    up.color = isolate(input$up.color),
                    down.color = isolate(input$down.color),
                    insig.color = isolate(input$insig.color),
                    sig.opacity = isolate(input$sig.opa),
                    insig.opacity = isolate(input$insig.opa),
                    sig.size = isolate(input$sig.size),
                    insig.size = isolate(input$insig.size),
                    label.size = isolate(input$lab.size),
                    webgl = isolate(input$webgl),
                    webgl.ratio = isolate(input$webgl.ratio),
                    show.counts = isolate(input$counts),
                    show.hl.counts = isolate(input$hl.counts),
                    counts.size = isolate(input$counts.size),
                    highlight.featsets = isolate(input$hl.genesets),
                    highlight.feats = highlight,
                    featsets = genesets,
                    highlight.feats.color = isolate(input$hl.genes.col),
                    highlight.feats.size = isolate(input$hl.genes.size),
                    highlight.feats.opac = isolate(input$hl.genes.opa),
                    highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                    highlight.feats.linewidth = isolate(input$hl.genes.lw),
                    highlight.featsets.color = isolate(input$hl.genesets.col),
                    highlight.featsets.size = isolate(input$hl.genesets.size),
                    highlight.featsets.opac = isolate(input$hl.genesets.opa),
                    highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                    highlight.featsets.linewidth = isolate(input$hl.genesets.lw))

    })

    # If only one dataset provided, don't render second dataset.
    if (length(gene.data) > 1) {
      output$gene2.summary <- renderDT({
        req(set2.genes)
        # Remove columns that are redundant or confusing.
        target <- which(names(set2.genes()) %in% c("neg|score", "neg|p-value", "neg|rank",
                                                   "neg|lfc", "pos|score", "pos|p-value", "pos|rank",
                                                   "pos|lfc", "RandomIndex", "Rank", "goodsgrna")) - 1

        df <- set2.genes()

        # Label overlapping hits between datasets if available.
        if (!is.null(common.hits())) {
          df$Overlap <- df$id %in% common.hits()
        }

        DT::datatable(df,
                      rownames = FALSE,
                      filter = "top",
                      extensions = c("Buttons"),
                      caption = paste0(input$gene.sel2, " Gene Summary"),
                      options = list(
                        search = list(regex = TRUE),
                        dom = 'Blfrtip',
                        buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                        pageLength = 10,
                        columnDefs = list(list(visible = FALSE, targets = target)))
        ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
      })

      output$gene2.vol <- renderPlotly({
        req(set2.genes)
        input$vol.update

        res <- set2.genes()

        hov.info <- c("hit_type", "num", "goodsgrna")

        # Remove common essential genes if needed.
        if (input$rem.ess & !is.null(res$essential)) {
          res <- res[!res$essential,]
        }

        # Remove DepMap stuff if requested.
        if (!is.null(depmap.gene)) {
          if (input$dep.crispr.ess) {
            res <- res[!res$DepMap_CRISPR_Essential,]
          }

          if (input$dep.crispr.sel) {
            res <- res[!res$DepMap_CRISPR_Selective,]
          }

          if (input$dep.rnai.ess) {
            res <- res[!res$DepMap_RNAi_Essential,]
          }

          if (input$dep.rnai.sel) {
            res <- res[!res$DepMap_RNAi_Selective,]
          }
        }

        highlight <- NULL
        if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
          highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
          highlight <- highlight.feats[highlight.feats != ""]
        }

        # Add common hits to highlight.
        if (isolate(input$highlight.common)) {
          highlight <- unique(c(common.hits(), highlight))
        }


        .make_volcano(res = res,
                      xlim = isolate(input$vol.x),
                      ylim = isolate(input$vol.y),
                      fc.thresh = isolate(input$gene.lfc.th),
                      fc.lines = isolate(input$vol.fcline),
                      sig.thresh = isolate(input$gene.fdr.th),
                      sig.line = isolate(input$vol.sigline),
                      h.id = h.id,
                      h.id.suffix = "_volc2",
                      sig.term = "FDR",
                      lfc.term = "LFC",
                      feat.term = "id",
                      hover.info = hov.info,
                      fs = clicked$volc2,
                      up.color = isolate(input$up.color),
                      down.color = isolate(input$down.color),
                      insig.color = isolate(input$insig.color),
                      sig.opacity = isolate(input$sig.opa),
                      insig.opacity = isolate(input$insig.opa),
                      sig.size = isolate(input$sig.size),
                      insig.size = isolate(input$insig.size),
                      label.size = isolate(input$lab.size),
                      webgl = isolate(input$webgl),
                      webgl.ratio = isolate(input$webgl.ratio),
                      show.counts = isolate(input$counts),
                      show.hl.counts = isolate(input$hl.counts),
                      counts.size = isolate(input$counts.size),
                      highlight.featsets = isolate(input$hl.genesets),
                      highlight.feats = highlight,
                      featsets = genesets,
                      highlight.feats.color = isolate(input$hl.genes.col),
                      highlight.feats.size = isolate(input$hl.genes.size),
                      highlight.feats.opac = isolate(input$hl.genes.opa),
                      highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                      highlight.feats.linewidth = isolate(input$hl.genes.lw),
                      highlight.featsets.color = isolate(input$hl.genesets.col),
                      highlight.featsets.size = isolate(input$hl.genesets.size),
                      highlight.featsets.opac = isolate(input$hl.genesets.opa),
                      highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                      highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
      })

      output$gene2.rank <- renderPlotly({
        req(set2.genes)
        input$rank.update

        hov.info <- c("hit_type", "num", "goodsgrna")

        df <- set2.genes()

        # Remove common essential genes if needed.
        if (input$rem.ess & !is.null(df$essential)) {
          df <- df[!df$essential,]
        }

        # Remove DepMap stuff if requested.
        if (!is.null(depmap.gene)) {
          if (input$dep.crispr.ess) {
            df <- df[!df$DepMap_CRISPR_Essential,]
          }

          if (input$dep.crispr.sel) {
            df <- df[!df$DepMap_CRISPR_Selective,]
          }

          if (input$dep.rnai.ess) {
            df <- df[!df$DepMap_RNAi_Essential,]
          }

          if (input$dep.rnai.sel) {
            df <- df[!df$DepMap_RNAi_Selective,]
          }
        }

        highlight <- NULL
        if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
          highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
          highlight <- highlight.feats[highlight.feats != ""]
        }

        # Add common hits to highlight.
        if (isolate(input$highlight.common)) {
          highlight <- unique(c(common.hits(), highlight))
        }

        .make_rank(df = df,
                   ylim = list(isolate(input$rank.y.min), isolate(input$rank.y.max)),
                   y.thresh = isolate(input$gene.lfc.th),
                   y.lines = isolate(input$rank.fcline),
                   sig.thresh = isolate(input$gene.fdr.th),
                   h.id = h.id,
                   h.id.suffix = "_rank2",
                   sig.term = "FDR",
                   y.term = "LFC",
                   x.term = "Rank",
                   feat.term = "id",
                   hover.info = hov.info,
                   fs = clicked$rank2,
                   up.color = isolate(input$up.color),
                   down.color = isolate(input$down.color),
                   insig.color = isolate(input$insig.color),
                   sig.opacity = isolate(input$sig.opa),
                   insig.opacity = isolate(input$insig.opa),
                   sig.size = isolate(input$sig.size),
                   insig.size = isolate(input$insig.size),
                   label.size = isolate(input$lab.size),
                   webgl = isolate(input$webgl),
                   webgl.ratio = isolate(input$webgl.ratio),
                   show.counts = isolate(input$counts),
                   show.hl.counts = isolate(input$hl.counts),
                   counts.size = isolate(input$counts.size),
                   highlight.featsets = isolate(input$hl.genesets),
                   highlight.feats = highlight,
                   featsets = genesets,
                   highlight.feats.color = isolate(input$hl.genes.col),
                   highlight.feats.size = isolate(input$hl.genes.size),
                   highlight.feats.opac = isolate(input$hl.genes.opa),
                   highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                   highlight.feats.linewidth = isolate(input$hl.genes.lw),
                   highlight.featsets.color = isolate(input$hl.genesets.col),
                   highlight.featsets.size = isolate(input$hl.genesets.size),
                   highlight.featsets.opac = isolate(input$hl.genesets.opa),
                   highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                   highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
      })

      output$gene2.lawn <- renderPlotly({
        req(set2.genes)
        input$lawn.update

        hov.info <- c("hit_type", "num", "goodsgrna")

        df <- set2.genes()

        # Remove common essential genes if needed.
        if (input$rem.ess & !is.null(df$essential)) {
          df <- df[!df$essential,]
        }

        # Remove DepMap stuff if requested.
        if (!is.null(depmap.gene)) {
          if (input$dep.crispr.ess) {
            df <- df[!df$DepMap_CRISPR_Essential,]
          }

          if (input$dep.crispr.sel) {
            df <- df[!df$DepMap_CRISPR_Selective,]
          }

          if (input$dep.rnai.ess) {
            df <- df[!df$DepMap_RNAi_Essential,]
          }

          if (input$dep.rnai.sel) {
            df <- df[!df$DepMap_RNAi_Selective,]
          }
        }

        highlight <- NULL
        if (!is.null(isolate(input$hl.genes)) & isolate(input$hl.genes) != "") {
          highlight.feats <- strsplit(input$hl.genes, ",|\\s|,\\s")[[1]]
          highlight <- highlight.feats[highlight.feats != ""]
        }

        # Add common hits to highlight.
        if (isolate(input$highlight.common)) {
          highlight <- unique(c(common.hits(), highlight))
        }

        .make_lawn(res = df,
                   ylim = isolate(input$lawn.y),
                   fc.thresh = isolate(input$gene.lfc.th),
                   sig.thresh = isolate(input$gene.fdr.th),
                   sig.line = isolate(input$lawn.sigline),
                   h.id = h.id,
                   h.id.suffix = "_lawn2",
                   sig.term = "FDR",
                   lfc.term = "LFC",
                   feat.term = "id",
                   x.term = "RandomIndex",
                   hover.info = hov.info,
                   fs = clicked$lawn2,
                   up.color = isolate(input$up.color),
                   down.color = isolate(input$down.color),
                   insig.color = isolate(input$insig.color),
                   sig.opacity = isolate(input$sig.opa),
                   insig.opacity = isolate(input$insig.opa),
                   sig.size = isolate(input$sig.size),
                   insig.size = isolate(input$insig.size),
                   label.size = isolate(input$lab.size),
                   webgl = isolate(input$webgl),
                   webgl.ratio = isolate(input$webgl.ratio),
                   show.counts = isolate(input$counts),
                   show.hl.counts = isolate(input$hl.counts),
                   counts.size = isolate(input$counts.size),
                   highlight.featsets = isolate(input$hl.genesets),
                   highlight.feats = highlight,
                   featsets = genesets,
                   highlight.feats.color = isolate(input$hl.genes.col),
                   highlight.feats.size = isolate(input$hl.genes.size),
                   highlight.feats.opac = isolate(input$hl.genes.opa),
                   highlight.feats.linecolor = isolate(input$hl.genes.lcol),
                   highlight.feats.linewidth = isolate(input$hl.genes.lw),
                   highlight.featsets.color = isolate(input$hl.genesets.col),
                   highlight.featsets.size = isolate(input$hl.genesets.size),
                   highlight.featsets.opac = isolate(input$hl.genesets.opa),
                   highlight.featsets.linecolor = isolate(input$hl.genesets.lcol),
                   highlight.featsets.linewidth = isolate(input$hl.genesets.lw))
      })
    }

    # If the Gene tab update button is pressed, click all the update buttons.
    observeEvent(input$gene.update, {
      shinyjs::click("lawn.update")
      shinyjs::click("vol.update")
      shinyjs::click("rank.update")
    })

    #---------------sgRNA Tab-----------------

    # Load the gene summaries for easy plotting.
    set1.sgrnas <- reactive({
      df <- sgrna.data[[input$sgrna.sel1]]
      df$Rank <- rank(df$LFC)
      df
    })

    if (length(sgrna.data) > 1) {
      set2.sgrnas <- reactive({
        df <- sgrna.data[[input$sgrna.sel2]]
        df$Rank <- rank(df$LFC)
        df
      })
    }

    # Summary tables and plots.
    output$sgrna1.summary <- renderDT({
      req(set1.sgrnas)

      df <- set1.sgrnas()

      DT::datatable(df,
                    rownames = FALSE,
                    filter = "top",
                    extensions = c("Buttons"),
                    caption = paste0(input$sgrna.sel1, " sgRNA Summary"),
                    options = list(
                      search = list(regex = TRUE),
                      pageLength = 10,
                      dom = 'Blfrtip',
                      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'))
      ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
    })

    output$sgrna1.counts <- renderPlotly({
      req(set1.sgrnas, input$sgrna.gene)

      df <- set1.sgrnas()
      df <- df[df$Gene == input$sgrna.gene,]

      .make_sgrna_pairplot(df)
    })

    output$sgrna1.rank <- renderPlotly({
      req(set1.sgrnas)
      input$rank.update

      df <- set1.sgrnas()

      hov.info <- c("Gene")

      highlight <- NULL
      highlight <- df$sgrna[df$Gene == input$sgrna.gene]

      .make_rank(df = df,
                 ylim = list(min(df$LFC) - 0.5, max(df$LFC) + 0.5),
                 y.thresh = 0,
                 y.lines = FALSE,
                 sig.thresh = 0,
                 h.id = h.id,
                 h.id.suffix = "_sgrank1",
                 sig.term = "FDR",
                 y.term = "LFC",
                 x.term = "Rank",
                 feat.term = "sgrna",
                 hover.info = hov.info,
                 fs = NULL,
                 up.color = "#A6A6A6",
                 down.color = "#A6A6A6",
                 insig.color = "#A6A6A6",
                 sig.opacity = 1,
                 insig.opacity = 1,
                 sig.size = 5,
                 insig.size = 5,
                 label.size = 8,
                 webgl = TRUE,
                 webgl.ratio = 7,
                 show.counts = FALSE,
                 show.hl.counts = FALSE,
                 counts.size = 8,
                 highlight.featsets = NULL,
                 highlight.feats = highlight,
                 featsets = NULL,
                 highlight.feats.color = "red",
                 highlight.feats.size = 8,
                 highlight.feats.opac = 1,
                 highlight.feats.linecolor = "black",
                 highlight.feats.linewidth = 0.5,
                 highlight.featsets.color = "#A6A6A6",
                 highlight.featsets.size = 7,
                 highlight.featsets.opac = 1,
                 highlight.featsets.linecolor = "black",
                 highlight.featsets.linewidth = 0.5)
    })

    output$sgrna1.detail <- renderDT({
      req(set1.sgrnas, input$sgrna.gene)

      df <- set1.sgrnas()
      df <- df[df$Gene == input$sgrna.gene,]

      target <- which(names(df) %in% c("control_mean", "treat_mean", "control_var", "adj_var", "high_in_treatment", "p.low", "p.high", "p.twosided", "score")) - 1

      DT::datatable(df,
                    rownames = FALSE,
                    filter = "top",
                    extensions = c("Buttons"),
                    caption = paste0(input$sgrna.sel1, " ", input$sgrna.gene, " sgRNA Details"),
                    options = list(
                      pageLength = 10,
                      dom = 'Blfrtip',
                      buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                      columnDefs = list(list(visible = FALSE, targets = target)))
      ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
    })

    if (length(sgrna.data) > 1) {
      output$sgrna2.summary <- renderDT({
        req(set2.sgrnas)

        df <- set2.sgrnas()

        DT::datatable(df,
                      rownames = FALSE,
                      filter = "top",
                      extensions = c("Buttons"),
                      caption = paste0(input$sgrna.sel2, " sgRNA Summary"),
                      options = list(
                        search = list(regex = TRUE),
                        pageLength = 10,
                        dom = 'Blfrtip',
                        buttons = c('copy', 'csv', 'excel', 'pdf', 'print'))
        ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
      })

      output$sgrna2.counts <- renderPlotly({
      req(set2.sgrnas, input$sgrna.gene)

      df <- set2.sgrnas()
      df <- df[df$Gene == input$sgrna.gene,]

      .make_sgrna_pairplot(df)
    })

      output$sgrna2.rank <- renderPlotly({
        req(set2.sgrnas)
        input$rank.update

        df <- set2.sgrnas()

        hov.info <- c("Gene")

        highlight <- NULL
        highlight <- df$sgrna[df$Gene == input$sgrna.gene]

        .make_rank(df = df,
                   ylim = list(min(df$LFC) - 0.5, max(df$LFC) + 0.5),
                   y.thresh = 0,
                   y.lines = FALSE,
                   sig.thresh = 0,
                   h.id = h.id,
                   h.id.suffix = "_sgrank1",
                   sig.term = "FDR",
                   y.term = "LFC",
                   x.term = "Rank",
                   feat.term = "sgrna",
                   hover.info = hov.info,
                   fs = NULL,
                   up.color = "#A6A6A6",
                   down.color = "#A6A6A6",
                   insig.color = "#A6A6A6",
                   sig.opacity = 1,
                   insig.opacity = 1,
                   sig.size = 5,
                   insig.size = 5,
                   label.size = 8,
                   webgl = TRUE,
                   webgl.ratio = 7,
                   show.counts = FALSE,
                   show.hl.counts = FALSE,
                   counts.size = 8,
                   highlight.featsets = NULL,
                   highlight.feats = highlight,
                   featsets = NULL,
                   highlight.feats.color = "red",
                   highlight.feats.size = 8,
                   highlight.feats.opac = 1,
                   highlight.feats.linecolor = "black",
                   highlight.feats.linewidth = 0.5,
                   highlight.featsets.color = "#A6A6A6",
                   highlight.featsets.size = 7,
                   highlight.featsets.opac = 1,
                   highlight.featsets.linecolor = "black",
                   highlight.featsets.linewidth = 0.5)
      })

      output$sgrna2.detail <- renderDT({
        req(set2.sgrnas, input$sgrna.gene)

        df <- set2.sgrnas()
        df <- df[df$Gene == input$sgrna.gene,]

        target <- which(names(df) %in% c("control_mean", "treat_mean", "control_var", "adj_var", "high_in_treatment", "p.low", "p.high", "p.twosided", "score")) - 1

        DT::datatable(df,
                      rownames = FALSE,
                      filter = "top",
                      extensions = c("Buttons"),
                      caption = paste0(input$sgrna.sel2, " ", input$sgrna.gene, " sgRNA Details"),
                      options = list(
                        pageLength = 10,
                        dom = 'Blfrtip',
                        buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                        columnDefs = list(list(visible = FALSE, targets = target)))
        ) %>% DT::formatStyle(0, target = "row", lineHeight = '50%')
      })
    }
  }

  if (return.app) {
    shinyApp(ui, server, options = list(height = height))
  } else {
    return(list(ui = ui, server = server))
  }
}
